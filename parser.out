Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERS
    AND
    ARRAY
    AT
    BEGIN
    BOOLAND
    BOOLOR
    BREAK
    CLASS
    COMMENT
    DOLLARSGN
    DUODOT
    ENSURE
    FOR
    IN
    LBRACE
    MINUSEQ
    NEXT
    NOT
    OR
    PIPE
    PLUSEQ
    RBRACE
    RETRY
    SELF
    SEMICOLON
    SUPER
    TILDE
    TRIDOT
    UNDERSCR
    UNTIL
    WHILE

Grammar

Rule 0     S' -> init
Rule 1     init -> cmmd
Rule 2     bool -> TRUE
Rule 3     bool -> FALSE
Rule 4     num -> INT
Rule 5     num -> FLOAT
Rule 6     num -> RAT
Rule 7     num -> COMPX
Rule 8     optr -> PLUS
Rule 9     optr -> MINUS
Rule 10    optr -> TIMES
Rule 11    optr -> DIVIDE
Rule 12    optr -> MODULE
Rule 13    optr -> EXPON
Rule 14    optn -> num optr num
Rule 15    comptn -> obj comptr obj
Rule 16    comptr -> EQCOMP
Rule 17    comptr -> LESSTH
Rule 18    comptr -> LESSEQTH
Rule 19    comptr -> GREATH
Rule 20    comptr -> GREATEQTH
Rule 21    comptr -> NOTEQ
Rule 22    var -> ID EQUALS obj
Rule 23    var -> ID EQUALS ID
Rule 24    var -> ID EQUALS NIL
Rule 25    func -> DEF ID LPAREN objs RPAREN cmmd END
Rule 26    func -> DEF ID LPAREN RPAREN cmmd END
Rule 27    func -> DEF ID cmmd END
Rule 28    func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END
Rule 29    func -> DEF ID LPAREN RPAREN cmmd RETURN obj END
Rule 30    func -> DEF ID cmmd RETURN obj END
Rule 31    else -> ELSE comptn cmmd
Rule 32    else -> ELSE bool cmmd
Rule 33    elsif -> ELSIF comptn cmmd
Rule 34    elsif -> ELSIF bool cmmd
Rule 35    elses -> else
Rule 36    elses -> elsif elses
Rule 37    control -> IF comptn cmmd END
Rule 38    control -> IF bool cmmd END
Rule 39    control -> IF comptn cmmd elses END
Rule 40    control -> IF bool cmmd elses END
Rule 41    control -> UNLESS comptn COLON cmmd END
Rule 42    control -> UNLESS bool COLON cmmd END
Rule 43    control -> UNLESS comptn cmmd elses END
Rule 44    control -> UNLESS bool cmmd elses END
Rule 45    when -> WHEN objs
Rule 46    when -> WHEN objs THEN
Rule 47    when -> WHEN comptn
Rule 48    whens -> when
Rule 49    whens -> when whens
Rule 50    control -> CASE ID whens else END
Rule 51    control -> CASE ID whens END
Rule 52    ids -> ID
Rule 53    ids -> ID COMMA ids
Rule 54    array -> LBRAKET objs RBRAKET
Rule 55    array -> LBRAKET ids RBRAKET
Rule 56    array -> LBRAKET objs COMMA ids RBRAKET
Rule 57    array -> LBRAKET ids COMMA objs RBRAKET
Rule 58    struc -> SET DOT NEW
Rule 59    struc -> SET DOT NEW LPAREN RPAREN
Rule 60    struc -> SET DOT NEW LPAREN array RPAREN
Rule 61    struc -> SET array
Rule 62    objs -> obj
Rule 63    objs -> obj COMMA objs
Rule 64    obj -> STRING
Rule 65    obj -> num
Rule 66    obj -> bool
Rule 67    obj -> range
Rule 68    range -> LPAREN INT DOT DOT INT RPAREN
Rule 69    range -> INT DOT DOT INT
Rule 70    range -> LPAREN STRING DOT DOT STRING
Rule 71    range -> STRING DOT DOT STRING
Rule 72    cmmd -> var
Rule 73    cmmd -> func
Rule 74    cmmd -> control
Rule 75    cmmd -> optn

Terminals, with rules where they appear

AMPERS               : 
AND                  : 
ARRAY                : 
AT                   : 
BEGIN                : 
BOOLAND              : 
BOOLOR               : 
BREAK                : 
CASE                 : 50 51
CLASS                : 
COLON                : 41 42
COMMA                : 53 56 57 63
COMMENT              : 
COMPX                : 7
DEF                  : 25 26 27 28 29 30
DIVIDE               : 11
DOLLARSGN            : 
DOT                  : 58 59 60 68 68 69 69 70 70 71 71
DUODOT               : 
ELSE                 : 31 32
ELSIF                : 33 34
END                  : 25 26 27 28 29 30 37 38 39 40 41 42 43 44 50 51
ENSURE               : 
EQCOMP               : 16
EQUALS               : 22 23 24
EXPON                : 13
FALSE                : 3
FLOAT                : 5
FOR                  : 
GREATEQTH            : 20
GREATH               : 19
ID                   : 22 23 23 24 25 26 27 28 29 30 50 51 52 53
IF                   : 37 38 39 40
IN                   : 
INT                  : 4 68 68 69 69
LBRACE               : 
LBRAKET              : 54 55 56 57
LESSEQTH             : 18
LESSTH               : 17
LPAREN               : 25 26 28 29 59 60 68 70
MINUS                : 9
MINUSEQ              : 
MODULE               : 12
NEW                  : 58 59 60
NEXT                 : 
NIL                  : 24
NOT                  : 
NOTEQ                : 21
OR                   : 
PIPE                 : 
PLUS                 : 8
PLUSEQ               : 
RAT                  : 6
RBRACE               : 
RBRAKET              : 54 55 56 57
RETRY                : 
RETURN               : 28 29 30
RPAREN               : 25 26 28 29 59 60 68
SELF                 : 
SEMICOLON            : 
SET                  : 58 59 60 61
STRING               : 64 70 70 71 71
SUPER                : 
THEN                 : 46
TILDE                : 
TIMES                : 10
TRIDOT               : 
TRUE                 : 2
UNDERSCR             : 
UNLESS               : 41 42 43 44
UNTIL                : 
WHEN                 : 45 46 47
WHILE                : 
error                : 

Nonterminals, with rules where they appear

array                : 60 61
bool                 : 32 34 38 40 42 44 66
cmmd                 : 1 25 26 27 28 29 30 31 32 33 34 37 38 39 40 41 42 43 44
comptn               : 31 33 37 39 41 43 47
comptr               : 15
control              : 74
else                 : 35 50
elses                : 36 39 40 43 44
elsif                : 36
func                 : 73
ids                  : 53 55 56 57
init                 : 0
num                  : 14 14 65
obj                  : 15 15 22 28 29 30 62 63
objs                 : 25 28 45 46 54 56 57 63
optn                 : 75
optr                 : 14
range                : 67
struc                : 
var                  : 72
when                 : 48 49
whens                : 49 50 51

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . cmmd
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    init                           shift and go to state 1
    cmmd                           shift and go to state 2
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 1

    (0) S' -> init .



state 2

    (1) init -> cmmd .

    $end            reduce using rule 1 (init -> cmmd .)


state 3

    (72) cmmd -> var .

    $end            reduce using rule 72 (cmmd -> var .)
    END             reduce using rule 72 (cmmd -> var .)
    RETURN          reduce using rule 72 (cmmd -> var .)
    ELSE            reduce using rule 72 (cmmd -> var .)
    ELSIF           reduce using rule 72 (cmmd -> var .)


state 4

    (73) cmmd -> func .

    $end            reduce using rule 73 (cmmd -> func .)
    END             reduce using rule 73 (cmmd -> func .)
    RETURN          reduce using rule 73 (cmmd -> func .)
    ELSE            reduce using rule 73 (cmmd -> func .)
    ELSIF           reduce using rule 73 (cmmd -> func .)


state 5

    (74) cmmd -> control .

    $end            reduce using rule 74 (cmmd -> control .)
    END             reduce using rule 74 (cmmd -> control .)
    RETURN          reduce using rule 74 (cmmd -> control .)
    ELSE            reduce using rule 74 (cmmd -> control .)
    ELSIF           reduce using rule 74 (cmmd -> control .)


state 6

    (75) cmmd -> optn .

    $end            reduce using rule 75 (cmmd -> optn .)
    END             reduce using rule 75 (cmmd -> optn .)
    RETURN          reduce using rule 75 (cmmd -> optn .)
    ELSE            reduce using rule 75 (cmmd -> optn .)
    ELSIF           reduce using rule 75 (cmmd -> optn .)


state 7

    (22) var -> ID . EQUALS obj
    (23) var -> ID . EQUALS ID
    (24) var -> ID . EQUALS NIL

    EQUALS          shift and go to state 17


state 8

    (25) func -> DEF . ID LPAREN objs RPAREN cmmd END
    (26) func -> DEF . ID LPAREN RPAREN cmmd END
    (27) func -> DEF . ID cmmd END
    (28) func -> DEF . ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> DEF . ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> DEF . ID cmmd RETURN obj END

    ID              shift and go to state 18


state 9

    (37) control -> IF . comptn cmmd END
    (38) control -> IF . bool cmmd END
    (39) control -> IF . comptn cmmd elses END
    (40) control -> IF . bool cmmd elses END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 28

    comptn                         shift and go to state 19
    bool                           shift and go to state 20
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26

state 10

    (41) control -> UNLESS . comptn COLON cmmd END
    (42) control -> UNLESS . bool COLON cmmd END
    (43) control -> UNLESS . comptn cmmd elses END
    (44) control -> UNLESS . bool cmmd elses END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 28

    comptn                         shift and go to state 29
    bool                           shift and go to state 30
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26

state 11

    (50) control -> CASE . ID whens else END
    (51) control -> CASE . ID whens END

    ID              shift and go to state 31


state 12

    (14) optn -> num . optr num
    (8) optr -> . PLUS
    (9) optr -> . MINUS
    (10) optr -> . TIMES
    (11) optr -> . DIVIDE
    (12) optr -> . MODULE
    (13) optr -> . EXPON

    PLUS            shift and go to state 33
    MINUS           shift and go to state 34
    TIMES           shift and go to state 35
    DIVIDE          shift and go to state 36
    MODULE          shift and go to state 37
    EXPON           shift and go to state 38

    optr                           shift and go to state 32

state 13

    (4) num -> INT .

    PLUS            reduce using rule 4 (num -> INT .)
    MINUS           reduce using rule 4 (num -> INT .)
    TIMES           reduce using rule 4 (num -> INT .)
    DIVIDE          reduce using rule 4 (num -> INT .)
    MODULE          reduce using rule 4 (num -> INT .)
    EXPON           reduce using rule 4 (num -> INT .)
    $end            reduce using rule 4 (num -> INT .)
    END             reduce using rule 4 (num -> INT .)
    RETURN          reduce using rule 4 (num -> INT .)
    ELSE            reduce using rule 4 (num -> INT .)
    ELSIF           reduce using rule 4 (num -> INT .)


state 14

    (5) num -> FLOAT .

    PLUS            reduce using rule 5 (num -> FLOAT .)
    MINUS           reduce using rule 5 (num -> FLOAT .)
    TIMES           reduce using rule 5 (num -> FLOAT .)
    DIVIDE          reduce using rule 5 (num -> FLOAT .)
    MODULE          reduce using rule 5 (num -> FLOAT .)
    EXPON           reduce using rule 5 (num -> FLOAT .)
    EQCOMP          reduce using rule 5 (num -> FLOAT .)
    LESSTH          reduce using rule 5 (num -> FLOAT .)
    LESSEQTH        reduce using rule 5 (num -> FLOAT .)
    GREATH          reduce using rule 5 (num -> FLOAT .)
    GREATEQTH       reduce using rule 5 (num -> FLOAT .)
    NOTEQ           reduce using rule 5 (num -> FLOAT .)
    $end            reduce using rule 5 (num -> FLOAT .)
    END             reduce using rule 5 (num -> FLOAT .)
    RETURN          reduce using rule 5 (num -> FLOAT .)
    ELSE            reduce using rule 5 (num -> FLOAT .)
    ELSIF           reduce using rule 5 (num -> FLOAT .)
    COMMA           reduce using rule 5 (num -> FLOAT .)
    RPAREN          reduce using rule 5 (num -> FLOAT .)
    ID              reduce using rule 5 (num -> FLOAT .)
    DEF             reduce using rule 5 (num -> FLOAT .)
    IF              reduce using rule 5 (num -> FLOAT .)
    UNLESS          reduce using rule 5 (num -> FLOAT .)
    CASE            reduce using rule 5 (num -> FLOAT .)
    INT             reduce using rule 5 (num -> FLOAT .)
    FLOAT           reduce using rule 5 (num -> FLOAT .)
    RAT             reduce using rule 5 (num -> FLOAT .)
    COMPX           reduce using rule 5 (num -> FLOAT .)
    COLON           reduce using rule 5 (num -> FLOAT .)
    WHEN            reduce using rule 5 (num -> FLOAT .)
    THEN            reduce using rule 5 (num -> FLOAT .)


state 15

    (6) num -> RAT .

    PLUS            reduce using rule 6 (num -> RAT .)
    MINUS           reduce using rule 6 (num -> RAT .)
    TIMES           reduce using rule 6 (num -> RAT .)
    DIVIDE          reduce using rule 6 (num -> RAT .)
    MODULE          reduce using rule 6 (num -> RAT .)
    EXPON           reduce using rule 6 (num -> RAT .)
    EQCOMP          reduce using rule 6 (num -> RAT .)
    LESSTH          reduce using rule 6 (num -> RAT .)
    LESSEQTH        reduce using rule 6 (num -> RAT .)
    GREATH          reduce using rule 6 (num -> RAT .)
    GREATEQTH       reduce using rule 6 (num -> RAT .)
    NOTEQ           reduce using rule 6 (num -> RAT .)
    $end            reduce using rule 6 (num -> RAT .)
    END             reduce using rule 6 (num -> RAT .)
    RETURN          reduce using rule 6 (num -> RAT .)
    ELSE            reduce using rule 6 (num -> RAT .)
    ELSIF           reduce using rule 6 (num -> RAT .)
    COMMA           reduce using rule 6 (num -> RAT .)
    RPAREN          reduce using rule 6 (num -> RAT .)
    ID              reduce using rule 6 (num -> RAT .)
    DEF             reduce using rule 6 (num -> RAT .)
    IF              reduce using rule 6 (num -> RAT .)
    UNLESS          reduce using rule 6 (num -> RAT .)
    CASE            reduce using rule 6 (num -> RAT .)
    INT             reduce using rule 6 (num -> RAT .)
    FLOAT           reduce using rule 6 (num -> RAT .)
    RAT             reduce using rule 6 (num -> RAT .)
    COMPX           reduce using rule 6 (num -> RAT .)
    COLON           reduce using rule 6 (num -> RAT .)
    WHEN            reduce using rule 6 (num -> RAT .)
    THEN            reduce using rule 6 (num -> RAT .)


state 16

    (7) num -> COMPX .

    PLUS            reduce using rule 7 (num -> COMPX .)
    MINUS           reduce using rule 7 (num -> COMPX .)
    TIMES           reduce using rule 7 (num -> COMPX .)
    DIVIDE          reduce using rule 7 (num -> COMPX .)
    MODULE          reduce using rule 7 (num -> COMPX .)
    EXPON           reduce using rule 7 (num -> COMPX .)
    EQCOMP          reduce using rule 7 (num -> COMPX .)
    LESSTH          reduce using rule 7 (num -> COMPX .)
    LESSEQTH        reduce using rule 7 (num -> COMPX .)
    GREATH          reduce using rule 7 (num -> COMPX .)
    GREATEQTH       reduce using rule 7 (num -> COMPX .)
    NOTEQ           reduce using rule 7 (num -> COMPX .)
    $end            reduce using rule 7 (num -> COMPX .)
    END             reduce using rule 7 (num -> COMPX .)
    RETURN          reduce using rule 7 (num -> COMPX .)
    ELSE            reduce using rule 7 (num -> COMPX .)
    ELSIF           reduce using rule 7 (num -> COMPX .)
    COMMA           reduce using rule 7 (num -> COMPX .)
    RPAREN          reduce using rule 7 (num -> COMPX .)
    ID              reduce using rule 7 (num -> COMPX .)
    DEF             reduce using rule 7 (num -> COMPX .)
    IF              reduce using rule 7 (num -> COMPX .)
    UNLESS          reduce using rule 7 (num -> COMPX .)
    CASE            reduce using rule 7 (num -> COMPX .)
    INT             reduce using rule 7 (num -> COMPX .)
    FLOAT           reduce using rule 7 (num -> COMPX .)
    RAT             reduce using rule 7 (num -> COMPX .)
    COMPX           reduce using rule 7 (num -> COMPX .)
    COLON           reduce using rule 7 (num -> COMPX .)
    WHEN            reduce using rule 7 (num -> COMPX .)
    THEN            reduce using rule 7 (num -> COMPX .)


state 17

    (22) var -> ID EQUALS . obj
    (23) var -> ID EQUALS . ID
    (24) var -> ID EQUALS . NIL
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    ID              shift and go to state 39
    NIL             shift and go to state 41
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    obj                            shift and go to state 40
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 18

    (25) func -> DEF ID . LPAREN objs RPAREN cmmd END
    (26) func -> DEF ID . LPAREN RPAREN cmmd END
    (27) func -> DEF ID . cmmd END
    (28) func -> DEF ID . LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> DEF ID . LPAREN RPAREN cmmd RETURN obj END
    (30) func -> DEF ID . cmmd RETURN obj END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    LPAREN          shift and go to state 43
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 44
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 19

    (37) control -> IF comptn . cmmd END
    (39) control -> IF comptn . cmmd elses END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 45
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 20

    (38) control -> IF bool . cmmd END
    (40) control -> IF bool . cmmd elses END
    (66) obj -> bool .
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 46
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 21

    (15) comptn -> obj . comptr obj
    (16) comptr -> . EQCOMP
    (17) comptr -> . LESSTH
    (18) comptr -> . LESSEQTH
    (19) comptr -> . GREATH
    (20) comptr -> . GREATEQTH
    (21) comptr -> . NOTEQ

    EQCOMP          shift and go to state 48
    LESSTH          shift and go to state 49
    LESSEQTH        shift and go to state 50
    GREATH          shift and go to state 51
    GREATEQTH       shift and go to state 52
    NOTEQ           shift and go to state 53

    comptr                         shift and go to state 47

state 22

    (2) bool -> TRUE .

    ID              reduce using rule 2 (bool -> TRUE .)
    DEF             reduce using rule 2 (bool -> TRUE .)
    IF              reduce using rule 2 (bool -> TRUE .)
    UNLESS          reduce using rule 2 (bool -> TRUE .)
    CASE            reduce using rule 2 (bool -> TRUE .)
    INT             reduce using rule 2 (bool -> TRUE .)
    FLOAT           reduce using rule 2 (bool -> TRUE .)
    RAT             reduce using rule 2 (bool -> TRUE .)
    COMPX           reduce using rule 2 (bool -> TRUE .)
    EQCOMP          reduce using rule 2 (bool -> TRUE .)
    LESSTH          reduce using rule 2 (bool -> TRUE .)
    LESSEQTH        reduce using rule 2 (bool -> TRUE .)
    GREATH          reduce using rule 2 (bool -> TRUE .)
    GREATEQTH       reduce using rule 2 (bool -> TRUE .)
    NOTEQ           reduce using rule 2 (bool -> TRUE .)
    COLON           reduce using rule 2 (bool -> TRUE .)
    $end            reduce using rule 2 (bool -> TRUE .)
    END             reduce using rule 2 (bool -> TRUE .)
    RETURN          reduce using rule 2 (bool -> TRUE .)
    ELSE            reduce using rule 2 (bool -> TRUE .)
    ELSIF           reduce using rule 2 (bool -> TRUE .)
    COMMA           reduce using rule 2 (bool -> TRUE .)
    RPAREN          reduce using rule 2 (bool -> TRUE .)
    WHEN            reduce using rule 2 (bool -> TRUE .)
    THEN            reduce using rule 2 (bool -> TRUE .)


state 23

    (3) bool -> FALSE .

    ID              reduce using rule 3 (bool -> FALSE .)
    DEF             reduce using rule 3 (bool -> FALSE .)
    IF              reduce using rule 3 (bool -> FALSE .)
    UNLESS          reduce using rule 3 (bool -> FALSE .)
    CASE            reduce using rule 3 (bool -> FALSE .)
    INT             reduce using rule 3 (bool -> FALSE .)
    FLOAT           reduce using rule 3 (bool -> FALSE .)
    RAT             reduce using rule 3 (bool -> FALSE .)
    COMPX           reduce using rule 3 (bool -> FALSE .)
    EQCOMP          reduce using rule 3 (bool -> FALSE .)
    LESSTH          reduce using rule 3 (bool -> FALSE .)
    LESSEQTH        reduce using rule 3 (bool -> FALSE .)
    GREATH          reduce using rule 3 (bool -> FALSE .)
    GREATEQTH       reduce using rule 3 (bool -> FALSE .)
    NOTEQ           reduce using rule 3 (bool -> FALSE .)
    COLON           reduce using rule 3 (bool -> FALSE .)
    $end            reduce using rule 3 (bool -> FALSE .)
    END             reduce using rule 3 (bool -> FALSE .)
    RETURN          reduce using rule 3 (bool -> FALSE .)
    ELSE            reduce using rule 3 (bool -> FALSE .)
    ELSIF           reduce using rule 3 (bool -> FALSE .)
    COMMA           reduce using rule 3 (bool -> FALSE .)
    RPAREN          reduce using rule 3 (bool -> FALSE .)
    WHEN            reduce using rule 3 (bool -> FALSE .)
    THEN            reduce using rule 3 (bool -> FALSE .)


state 24

    (64) obj -> STRING .
    (71) range -> STRING . DOT DOT STRING

    EQCOMP          reduce using rule 64 (obj -> STRING .)
    LESSTH          reduce using rule 64 (obj -> STRING .)
    LESSEQTH        reduce using rule 64 (obj -> STRING .)
    GREATH          reduce using rule 64 (obj -> STRING .)
    GREATEQTH       reduce using rule 64 (obj -> STRING .)
    NOTEQ           reduce using rule 64 (obj -> STRING .)
    $end            reduce using rule 64 (obj -> STRING .)
    END             reduce using rule 64 (obj -> STRING .)
    RETURN          reduce using rule 64 (obj -> STRING .)
    ELSE            reduce using rule 64 (obj -> STRING .)
    ELSIF           reduce using rule 64 (obj -> STRING .)
    COMMA           reduce using rule 64 (obj -> STRING .)
    RPAREN          reduce using rule 64 (obj -> STRING .)
    ID              reduce using rule 64 (obj -> STRING .)
    DEF             reduce using rule 64 (obj -> STRING .)
    IF              reduce using rule 64 (obj -> STRING .)
    UNLESS          reduce using rule 64 (obj -> STRING .)
    CASE            reduce using rule 64 (obj -> STRING .)
    INT             reduce using rule 64 (obj -> STRING .)
    FLOAT           reduce using rule 64 (obj -> STRING .)
    RAT             reduce using rule 64 (obj -> STRING .)
    COMPX           reduce using rule 64 (obj -> STRING .)
    COLON           reduce using rule 64 (obj -> STRING .)
    WHEN            reduce using rule 64 (obj -> STRING .)
    THEN            reduce using rule 64 (obj -> STRING .)
    DOT             shift and go to state 54


state 25

    (65) obj -> num .

    EQCOMP          reduce using rule 65 (obj -> num .)
    LESSTH          reduce using rule 65 (obj -> num .)
    LESSEQTH        reduce using rule 65 (obj -> num .)
    GREATH          reduce using rule 65 (obj -> num .)
    GREATEQTH       reduce using rule 65 (obj -> num .)
    NOTEQ           reduce using rule 65 (obj -> num .)
    $end            reduce using rule 65 (obj -> num .)
    END             reduce using rule 65 (obj -> num .)
    RETURN          reduce using rule 65 (obj -> num .)
    ELSE            reduce using rule 65 (obj -> num .)
    ELSIF           reduce using rule 65 (obj -> num .)
    COMMA           reduce using rule 65 (obj -> num .)
    RPAREN          reduce using rule 65 (obj -> num .)
    ID              reduce using rule 65 (obj -> num .)
    DEF             reduce using rule 65 (obj -> num .)
    IF              reduce using rule 65 (obj -> num .)
    UNLESS          reduce using rule 65 (obj -> num .)
    CASE            reduce using rule 65 (obj -> num .)
    INT             reduce using rule 65 (obj -> num .)
    FLOAT           reduce using rule 65 (obj -> num .)
    RAT             reduce using rule 65 (obj -> num .)
    COMPX           reduce using rule 65 (obj -> num .)
    COLON           reduce using rule 65 (obj -> num .)
    WHEN            reduce using rule 65 (obj -> num .)
    THEN            reduce using rule 65 (obj -> num .)


state 26

    (67) obj -> range .

    EQCOMP          reduce using rule 67 (obj -> range .)
    LESSTH          reduce using rule 67 (obj -> range .)
    LESSEQTH        reduce using rule 67 (obj -> range .)
    GREATH          reduce using rule 67 (obj -> range .)
    GREATEQTH       reduce using rule 67 (obj -> range .)
    NOTEQ           reduce using rule 67 (obj -> range .)
    $end            reduce using rule 67 (obj -> range .)
    END             reduce using rule 67 (obj -> range .)
    RETURN          reduce using rule 67 (obj -> range .)
    ELSE            reduce using rule 67 (obj -> range .)
    ELSIF           reduce using rule 67 (obj -> range .)
    COMMA           reduce using rule 67 (obj -> range .)
    RPAREN          reduce using rule 67 (obj -> range .)
    ID              reduce using rule 67 (obj -> range .)
    DEF             reduce using rule 67 (obj -> range .)
    IF              reduce using rule 67 (obj -> range .)
    UNLESS          reduce using rule 67 (obj -> range .)
    CASE            reduce using rule 67 (obj -> range .)
    INT             reduce using rule 67 (obj -> range .)
    FLOAT           reduce using rule 67 (obj -> range .)
    RAT             reduce using rule 67 (obj -> range .)
    COMPX           reduce using rule 67 (obj -> range .)
    COLON           reduce using rule 67 (obj -> range .)
    WHEN            reduce using rule 67 (obj -> range .)
    THEN            reduce using rule 67 (obj -> range .)


state 27

    (4) num -> INT .
    (69) range -> INT . DOT DOT INT

    EQCOMP          reduce using rule 4 (num -> INT .)
    LESSTH          reduce using rule 4 (num -> INT .)
    LESSEQTH        reduce using rule 4 (num -> INT .)
    GREATH          reduce using rule 4 (num -> INT .)
    GREATEQTH       reduce using rule 4 (num -> INT .)
    NOTEQ           reduce using rule 4 (num -> INT .)
    $end            reduce using rule 4 (num -> INT .)
    END             reduce using rule 4 (num -> INT .)
    RETURN          reduce using rule 4 (num -> INT .)
    ELSE            reduce using rule 4 (num -> INT .)
    ELSIF           reduce using rule 4 (num -> INT .)
    COMMA           reduce using rule 4 (num -> INT .)
    RPAREN          reduce using rule 4 (num -> INT .)
    ID              reduce using rule 4 (num -> INT .)
    DEF             reduce using rule 4 (num -> INT .)
    IF              reduce using rule 4 (num -> INT .)
    UNLESS          reduce using rule 4 (num -> INT .)
    CASE            reduce using rule 4 (num -> INT .)
    INT             reduce using rule 4 (num -> INT .)
    FLOAT           reduce using rule 4 (num -> INT .)
    RAT             reduce using rule 4 (num -> INT .)
    COMPX           reduce using rule 4 (num -> INT .)
    COLON           reduce using rule 4 (num -> INT .)
    WHEN            reduce using rule 4 (num -> INT .)
    THEN            reduce using rule 4 (num -> INT .)
    DOT             shift and go to state 55


state 28

    (68) range -> LPAREN . INT DOT DOT INT RPAREN
    (70) range -> LPAREN . STRING DOT DOT STRING

    INT             shift and go to state 56
    STRING          shift and go to state 57


state 29

    (41) control -> UNLESS comptn . COLON cmmd END
    (43) control -> UNLESS comptn . cmmd elses END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    COLON           shift and go to state 58
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 59
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 30

    (42) control -> UNLESS bool . COLON cmmd END
    (44) control -> UNLESS bool . cmmd elses END
    (66) obj -> bool .
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    COLON           shift and go to state 60
    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 61
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 31

    (50) control -> CASE ID . whens else END
    (51) control -> CASE ID . whens END
    (48) whens -> . when
    (49) whens -> . when whens
    (45) when -> . WHEN objs
    (46) when -> . WHEN objs THEN
    (47) when -> . WHEN comptn

    WHEN            shift and go to state 64

    whens                          shift and go to state 62
    when                           shift and go to state 63

state 32

    (14) optn -> num optr . num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    num                            shift and go to state 65

state 33

    (8) optr -> PLUS .

    INT             reduce using rule 8 (optr -> PLUS .)
    FLOAT           reduce using rule 8 (optr -> PLUS .)
    RAT             reduce using rule 8 (optr -> PLUS .)
    COMPX           reduce using rule 8 (optr -> PLUS .)


state 34

    (9) optr -> MINUS .

    INT             reduce using rule 9 (optr -> MINUS .)
    FLOAT           reduce using rule 9 (optr -> MINUS .)
    RAT             reduce using rule 9 (optr -> MINUS .)
    COMPX           reduce using rule 9 (optr -> MINUS .)


state 35

    (10) optr -> TIMES .

    INT             reduce using rule 10 (optr -> TIMES .)
    FLOAT           reduce using rule 10 (optr -> TIMES .)
    RAT             reduce using rule 10 (optr -> TIMES .)
    COMPX           reduce using rule 10 (optr -> TIMES .)


state 36

    (11) optr -> DIVIDE .

    INT             reduce using rule 11 (optr -> DIVIDE .)
    FLOAT           reduce using rule 11 (optr -> DIVIDE .)
    RAT             reduce using rule 11 (optr -> DIVIDE .)
    COMPX           reduce using rule 11 (optr -> DIVIDE .)


state 37

    (12) optr -> MODULE .

    INT             reduce using rule 12 (optr -> MODULE .)
    FLOAT           reduce using rule 12 (optr -> MODULE .)
    RAT             reduce using rule 12 (optr -> MODULE .)
    COMPX           reduce using rule 12 (optr -> MODULE .)


state 38

    (13) optr -> EXPON .

    INT             reduce using rule 13 (optr -> EXPON .)
    FLOAT           reduce using rule 13 (optr -> EXPON .)
    RAT             reduce using rule 13 (optr -> EXPON .)
    COMPX           reduce using rule 13 (optr -> EXPON .)


state 39

    (23) var -> ID EQUALS ID .

    $end            reduce using rule 23 (var -> ID EQUALS ID .)
    END             reduce using rule 23 (var -> ID EQUALS ID .)
    RETURN          reduce using rule 23 (var -> ID EQUALS ID .)
    ELSE            reduce using rule 23 (var -> ID EQUALS ID .)
    ELSIF           reduce using rule 23 (var -> ID EQUALS ID .)


state 40

    (22) var -> ID EQUALS obj .

    $end            reduce using rule 22 (var -> ID EQUALS obj .)
    END             reduce using rule 22 (var -> ID EQUALS obj .)
    RETURN          reduce using rule 22 (var -> ID EQUALS obj .)
    ELSE            reduce using rule 22 (var -> ID EQUALS obj .)
    ELSIF           reduce using rule 22 (var -> ID EQUALS obj .)


state 41

    (24) var -> ID EQUALS NIL .

    $end            reduce using rule 24 (var -> ID EQUALS NIL .)
    END             reduce using rule 24 (var -> ID EQUALS NIL .)
    RETURN          reduce using rule 24 (var -> ID EQUALS NIL .)
    ELSE            reduce using rule 24 (var -> ID EQUALS NIL .)
    ELSIF           reduce using rule 24 (var -> ID EQUALS NIL .)


state 42

    (66) obj -> bool .

    $end            reduce using rule 66 (obj -> bool .)
    END             reduce using rule 66 (obj -> bool .)
    RETURN          reduce using rule 66 (obj -> bool .)
    ELSE            reduce using rule 66 (obj -> bool .)
    ELSIF           reduce using rule 66 (obj -> bool .)
    COMMA           reduce using rule 66 (obj -> bool .)
    RPAREN          reduce using rule 66 (obj -> bool .)
    ID              reduce using rule 66 (obj -> bool .)
    DEF             reduce using rule 66 (obj -> bool .)
    IF              reduce using rule 66 (obj -> bool .)
    UNLESS          reduce using rule 66 (obj -> bool .)
    CASE            reduce using rule 66 (obj -> bool .)
    INT             reduce using rule 66 (obj -> bool .)
    FLOAT           reduce using rule 66 (obj -> bool .)
    RAT             reduce using rule 66 (obj -> bool .)
    COMPX           reduce using rule 66 (obj -> bool .)
    COLON           reduce using rule 66 (obj -> bool .)
    WHEN            reduce using rule 66 (obj -> bool .)
    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    THEN            reduce using rule 66 (obj -> bool .)


state 43

    (25) func -> DEF ID LPAREN . objs RPAREN cmmd END
    (26) func -> DEF ID LPAREN . RPAREN cmmd END
    (28) func -> DEF ID LPAREN . objs RPAREN cmmd RETURN obj END
    (29) func -> DEF ID LPAREN . RPAREN cmmd RETURN obj END
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    RPAREN          shift and go to state 67
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    objs                           shift and go to state 66
    obj                            shift and go to state 68
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 44

    (27) func -> DEF ID cmmd . END
    (30) func -> DEF ID cmmd . RETURN obj END

    END             shift and go to state 69
    RETURN          shift and go to state 70


state 45

    (37) control -> IF comptn cmmd . END
    (39) control -> IF comptn cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    END             shift and go to state 71
    ELSE            shift and go to state 75
    ELSIF           shift and go to state 76

    elses                          shift and go to state 72
    else                           shift and go to state 73
    elsif                          shift and go to state 74

state 46

    (38) control -> IF bool cmmd . END
    (40) control -> IF bool cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    END             shift and go to state 77
    ELSE            shift and go to state 75
    ELSIF           shift and go to state 76

    elses                          shift and go to state 78
    else                           shift and go to state 73
    elsif                          shift and go to state 74

state 47

    (15) comptn -> obj comptr . obj
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    obj                            shift and go to state 79
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 48

    (16) comptr -> EQCOMP .

    STRING          reduce using rule 16 (comptr -> EQCOMP .)
    INT             reduce using rule 16 (comptr -> EQCOMP .)
    FLOAT           reduce using rule 16 (comptr -> EQCOMP .)
    RAT             reduce using rule 16 (comptr -> EQCOMP .)
    COMPX           reduce using rule 16 (comptr -> EQCOMP .)
    TRUE            reduce using rule 16 (comptr -> EQCOMP .)
    FALSE           reduce using rule 16 (comptr -> EQCOMP .)
    LPAREN          reduce using rule 16 (comptr -> EQCOMP .)


state 49

    (17) comptr -> LESSTH .

    STRING          reduce using rule 17 (comptr -> LESSTH .)
    INT             reduce using rule 17 (comptr -> LESSTH .)
    FLOAT           reduce using rule 17 (comptr -> LESSTH .)
    RAT             reduce using rule 17 (comptr -> LESSTH .)
    COMPX           reduce using rule 17 (comptr -> LESSTH .)
    TRUE            reduce using rule 17 (comptr -> LESSTH .)
    FALSE           reduce using rule 17 (comptr -> LESSTH .)
    LPAREN          reduce using rule 17 (comptr -> LESSTH .)


state 50

    (18) comptr -> LESSEQTH .

    STRING          reduce using rule 18 (comptr -> LESSEQTH .)
    INT             reduce using rule 18 (comptr -> LESSEQTH .)
    FLOAT           reduce using rule 18 (comptr -> LESSEQTH .)
    RAT             reduce using rule 18 (comptr -> LESSEQTH .)
    COMPX           reduce using rule 18 (comptr -> LESSEQTH .)
    TRUE            reduce using rule 18 (comptr -> LESSEQTH .)
    FALSE           reduce using rule 18 (comptr -> LESSEQTH .)
    LPAREN          reduce using rule 18 (comptr -> LESSEQTH .)


state 51

    (19) comptr -> GREATH .

    STRING          reduce using rule 19 (comptr -> GREATH .)
    INT             reduce using rule 19 (comptr -> GREATH .)
    FLOAT           reduce using rule 19 (comptr -> GREATH .)
    RAT             reduce using rule 19 (comptr -> GREATH .)
    COMPX           reduce using rule 19 (comptr -> GREATH .)
    TRUE            reduce using rule 19 (comptr -> GREATH .)
    FALSE           reduce using rule 19 (comptr -> GREATH .)
    LPAREN          reduce using rule 19 (comptr -> GREATH .)


state 52

    (20) comptr -> GREATEQTH .

    STRING          reduce using rule 20 (comptr -> GREATEQTH .)
    INT             reduce using rule 20 (comptr -> GREATEQTH .)
    FLOAT           reduce using rule 20 (comptr -> GREATEQTH .)
    RAT             reduce using rule 20 (comptr -> GREATEQTH .)
    COMPX           reduce using rule 20 (comptr -> GREATEQTH .)
    TRUE            reduce using rule 20 (comptr -> GREATEQTH .)
    FALSE           reduce using rule 20 (comptr -> GREATEQTH .)
    LPAREN          reduce using rule 20 (comptr -> GREATEQTH .)


state 53

    (21) comptr -> NOTEQ .

    STRING          reduce using rule 21 (comptr -> NOTEQ .)
    INT             reduce using rule 21 (comptr -> NOTEQ .)
    FLOAT           reduce using rule 21 (comptr -> NOTEQ .)
    RAT             reduce using rule 21 (comptr -> NOTEQ .)
    COMPX           reduce using rule 21 (comptr -> NOTEQ .)
    TRUE            reduce using rule 21 (comptr -> NOTEQ .)
    FALSE           reduce using rule 21 (comptr -> NOTEQ .)
    LPAREN          reduce using rule 21 (comptr -> NOTEQ .)


state 54

    (71) range -> STRING DOT . DOT STRING

    DOT             shift and go to state 80


state 55

    (69) range -> INT DOT . DOT INT

    DOT             shift and go to state 81


state 56

    (68) range -> LPAREN INT . DOT DOT INT RPAREN

    DOT             shift and go to state 82


state 57

    (70) range -> LPAREN STRING . DOT DOT STRING

    DOT             shift and go to state 83


state 58

    (41) control -> UNLESS comptn COLON . cmmd END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 84
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 59

    (43) control -> UNLESS comptn cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 75
    ELSIF           shift and go to state 76

    elses                          shift and go to state 85
    else                           shift and go to state 73
    elsif                          shift and go to state 74

state 60

    (42) control -> UNLESS bool COLON . cmmd END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 86
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 61

    (44) control -> UNLESS bool cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 75
    ELSIF           shift and go to state 76

    elses                          shift and go to state 87
    else                           shift and go to state 73
    elsif                          shift and go to state 74

state 62

    (50) control -> CASE ID whens . else END
    (51) control -> CASE ID whens . END
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd

    END             shift and go to state 89
    ELSE            shift and go to state 75

    else                           shift and go to state 88

state 63

    (48) whens -> when .
    (49) whens -> when . whens
    (48) whens -> . when
    (49) whens -> . when whens
    (45) when -> . WHEN objs
    (46) when -> . WHEN objs THEN
    (47) when -> . WHEN comptn

    END             reduce using rule 48 (whens -> when .)
    ELSE            reduce using rule 48 (whens -> when .)
    WHEN            shift and go to state 64

    when                           shift and go to state 63
    whens                          shift and go to state 90

state 64

    (45) when -> WHEN . objs
    (46) when -> WHEN . objs THEN
    (47) when -> WHEN . comptn
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (15) comptn -> . obj comptr obj
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    objs                           shift and go to state 91
    comptn                         shift and go to state 92
    obj                            shift and go to state 93
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 65

    (14) optn -> num optr num .

    $end            reduce using rule 14 (optn -> num optr num .)
    END             reduce using rule 14 (optn -> num optr num .)
    RETURN          reduce using rule 14 (optn -> num optr num .)
    ELSE            reduce using rule 14 (optn -> num optr num .)
    ELSIF           reduce using rule 14 (optn -> num optr num .)


state 66

    (25) func -> DEF ID LPAREN objs . RPAREN cmmd END
    (28) func -> DEF ID LPAREN objs . RPAREN cmmd RETURN obj END

    RPAREN          shift and go to state 94


state 67

    (26) func -> DEF ID LPAREN RPAREN . cmmd END
    (29) func -> DEF ID LPAREN RPAREN . cmmd RETURN obj END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 95
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 68

    (62) objs -> obj .
    (63) objs -> obj . COMMA objs

    RPAREN          reduce using rule 62 (objs -> obj .)
    THEN            reduce using rule 62 (objs -> obj .)
    WHEN            reduce using rule 62 (objs -> obj .)
    END             reduce using rule 62 (objs -> obj .)
    ELSE            reduce using rule 62 (objs -> obj .)
    COMMA           shift and go to state 96


state 69

    (27) func -> DEF ID cmmd END .

    $end            reduce using rule 27 (func -> DEF ID cmmd END .)
    END             reduce using rule 27 (func -> DEF ID cmmd END .)
    RETURN          reduce using rule 27 (func -> DEF ID cmmd END .)
    ELSE            reduce using rule 27 (func -> DEF ID cmmd END .)
    ELSIF           reduce using rule 27 (func -> DEF ID cmmd END .)


state 70

    (30) func -> DEF ID cmmd RETURN . obj END
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    obj                            shift and go to state 97
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 71

    (37) control -> IF comptn cmmd END .

    $end            reduce using rule 37 (control -> IF comptn cmmd END .)
    END             reduce using rule 37 (control -> IF comptn cmmd END .)
    RETURN          reduce using rule 37 (control -> IF comptn cmmd END .)
    ELSE            reduce using rule 37 (control -> IF comptn cmmd END .)
    ELSIF           reduce using rule 37 (control -> IF comptn cmmd END .)


state 72

    (39) control -> IF comptn cmmd elses . END

    END             shift and go to state 98


state 73

    (35) elses -> else .

    END             reduce using rule 35 (elses -> else .)


state 74

    (36) elses -> elsif . elses
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 75
    ELSIF           shift and go to state 76

    elsif                          shift and go to state 74
    elses                          shift and go to state 99
    else                           shift and go to state 73

state 75

    (31) else -> ELSE . comptn cmmd
    (32) else -> ELSE . bool cmmd
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 28

    comptn                         shift and go to state 100
    bool                           shift and go to state 101
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26

state 76

    (33) elsif -> ELSIF . comptn cmmd
    (34) elsif -> ELSIF . bool cmmd
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 28

    comptn                         shift and go to state 102
    bool                           shift and go to state 103
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26

state 77

    (38) control -> IF bool cmmd END .

    $end            reduce using rule 38 (control -> IF bool cmmd END .)
    END             reduce using rule 38 (control -> IF bool cmmd END .)
    RETURN          reduce using rule 38 (control -> IF bool cmmd END .)
    ELSE            reduce using rule 38 (control -> IF bool cmmd END .)
    ELSIF           reduce using rule 38 (control -> IF bool cmmd END .)


state 78

    (40) control -> IF bool cmmd elses . END

    END             shift and go to state 104


state 79

    (15) comptn -> obj comptr obj .

    ID              reduce using rule 15 (comptn -> obj comptr obj .)
    DEF             reduce using rule 15 (comptn -> obj comptr obj .)
    IF              reduce using rule 15 (comptn -> obj comptr obj .)
    UNLESS          reduce using rule 15 (comptn -> obj comptr obj .)
    CASE            reduce using rule 15 (comptn -> obj comptr obj .)
    INT             reduce using rule 15 (comptn -> obj comptr obj .)
    FLOAT           reduce using rule 15 (comptn -> obj comptr obj .)
    RAT             reduce using rule 15 (comptn -> obj comptr obj .)
    COMPX           reduce using rule 15 (comptn -> obj comptr obj .)
    COLON           reduce using rule 15 (comptn -> obj comptr obj .)
    WHEN            reduce using rule 15 (comptn -> obj comptr obj .)
    END             reduce using rule 15 (comptn -> obj comptr obj .)
    ELSE            reduce using rule 15 (comptn -> obj comptr obj .)


state 80

    (71) range -> STRING DOT DOT . STRING

    STRING          shift and go to state 105


state 81

    (69) range -> INT DOT DOT . INT

    INT             shift and go to state 106


state 82

    (68) range -> LPAREN INT DOT . DOT INT RPAREN

    DOT             shift and go to state 107


state 83

    (70) range -> LPAREN STRING DOT . DOT STRING

    DOT             shift and go to state 108


state 84

    (41) control -> UNLESS comptn COLON cmmd . END

    END             shift and go to state 109


state 85

    (43) control -> UNLESS comptn cmmd elses . END

    END             shift and go to state 110


state 86

    (42) control -> UNLESS bool COLON cmmd . END

    END             shift and go to state 111


state 87

    (44) control -> UNLESS bool cmmd elses . END

    END             shift and go to state 112


state 88

    (50) control -> CASE ID whens else . END

    END             shift and go to state 113


state 89

    (51) control -> CASE ID whens END .

    $end            reduce using rule 51 (control -> CASE ID whens END .)
    END             reduce using rule 51 (control -> CASE ID whens END .)
    RETURN          reduce using rule 51 (control -> CASE ID whens END .)
    ELSE            reduce using rule 51 (control -> CASE ID whens END .)
    ELSIF           reduce using rule 51 (control -> CASE ID whens END .)


state 90

    (49) whens -> when whens .

    END             reduce using rule 49 (whens -> when whens .)
    ELSE            reduce using rule 49 (whens -> when whens .)


state 91

    (45) when -> WHEN objs .
    (46) when -> WHEN objs . THEN

    WHEN            reduce using rule 45 (when -> WHEN objs .)
    END             reduce using rule 45 (when -> WHEN objs .)
    ELSE            reduce using rule 45 (when -> WHEN objs .)
    THEN            shift and go to state 114


state 92

    (47) when -> WHEN comptn .

    WHEN            reduce using rule 47 (when -> WHEN comptn .)
    END             reduce using rule 47 (when -> WHEN comptn .)
    ELSE            reduce using rule 47 (when -> WHEN comptn .)


state 93

    (62) objs -> obj .
    (63) objs -> obj . COMMA objs
    (15) comptn -> obj . comptr obj
    (16) comptr -> . EQCOMP
    (17) comptr -> . LESSTH
    (18) comptr -> . LESSEQTH
    (19) comptr -> . GREATH
    (20) comptr -> . GREATEQTH
    (21) comptr -> . NOTEQ

    THEN            reduce using rule 62 (objs -> obj .)
    WHEN            reduce using rule 62 (objs -> obj .)
    END             reduce using rule 62 (objs -> obj .)
    ELSE            reduce using rule 62 (objs -> obj .)
    COMMA           shift and go to state 96
    EQCOMP          shift and go to state 48
    LESSTH          shift and go to state 49
    LESSEQTH        shift and go to state 50
    GREATH          shift and go to state 51
    GREATEQTH       shift and go to state 52
    NOTEQ           shift and go to state 53

    comptr                         shift and go to state 47

state 94

    (25) func -> DEF ID LPAREN objs RPAREN . cmmd END
    (28) func -> DEF ID LPAREN objs RPAREN . cmmd RETURN obj END
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 115
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 95

    (26) func -> DEF ID LPAREN RPAREN cmmd . END
    (29) func -> DEF ID LPAREN RPAREN cmmd . RETURN obj END

    END             shift and go to state 116
    RETURN          shift and go to state 117


state 96

    (63) objs -> obj COMMA . objs
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    obj                            shift and go to state 68
    objs                           shift and go to state 118
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 97

    (30) func -> DEF ID cmmd RETURN obj . END

    END             shift and go to state 119


state 98

    (39) control -> IF comptn cmmd elses END .

    $end            reduce using rule 39 (control -> IF comptn cmmd elses END .)
    END             reduce using rule 39 (control -> IF comptn cmmd elses END .)
    RETURN          reduce using rule 39 (control -> IF comptn cmmd elses END .)
    ELSE            reduce using rule 39 (control -> IF comptn cmmd elses END .)
    ELSIF           reduce using rule 39 (control -> IF comptn cmmd elses END .)


state 99

    (36) elses -> elsif elses .

    END             reduce using rule 36 (elses -> elsif elses .)


state 100

    (31) else -> ELSE comptn . cmmd
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 120
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 101

    (32) else -> ELSE bool . cmmd
    (66) obj -> bool .
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 121
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 102

    (33) elsif -> ELSIF comptn . cmmd
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 122
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 103

    (34) elsif -> ELSIF bool . cmmd
    (66) obj -> bool .
    (72) cmmd -> . var
    (73) cmmd -> . func
    (74) cmmd -> . control
    (75) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 123
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 104

    (40) control -> IF bool cmmd elses END .

    $end            reduce using rule 40 (control -> IF bool cmmd elses END .)
    END             reduce using rule 40 (control -> IF bool cmmd elses END .)
    RETURN          reduce using rule 40 (control -> IF bool cmmd elses END .)
    ELSE            reduce using rule 40 (control -> IF bool cmmd elses END .)
    ELSIF           reduce using rule 40 (control -> IF bool cmmd elses END .)


state 105

    (71) range -> STRING DOT DOT STRING .

    EQCOMP          reduce using rule 71 (range -> STRING DOT DOT STRING .)
    LESSTH          reduce using rule 71 (range -> STRING DOT DOT STRING .)
    LESSEQTH        reduce using rule 71 (range -> STRING DOT DOT STRING .)
    GREATH          reduce using rule 71 (range -> STRING DOT DOT STRING .)
    GREATEQTH       reduce using rule 71 (range -> STRING DOT DOT STRING .)
    NOTEQ           reduce using rule 71 (range -> STRING DOT DOT STRING .)
    $end            reduce using rule 71 (range -> STRING DOT DOT STRING .)
    END             reduce using rule 71 (range -> STRING DOT DOT STRING .)
    RETURN          reduce using rule 71 (range -> STRING DOT DOT STRING .)
    ELSE            reduce using rule 71 (range -> STRING DOT DOT STRING .)
    ELSIF           reduce using rule 71 (range -> STRING DOT DOT STRING .)
    COMMA           reduce using rule 71 (range -> STRING DOT DOT STRING .)
    RPAREN          reduce using rule 71 (range -> STRING DOT DOT STRING .)
    ID              reduce using rule 71 (range -> STRING DOT DOT STRING .)
    DEF             reduce using rule 71 (range -> STRING DOT DOT STRING .)
    IF              reduce using rule 71 (range -> STRING DOT DOT STRING .)
    UNLESS          reduce using rule 71 (range -> STRING DOT DOT STRING .)
    CASE            reduce using rule 71 (range -> STRING DOT DOT STRING .)
    INT             reduce using rule 71 (range -> STRING DOT DOT STRING .)
    FLOAT           reduce using rule 71 (range -> STRING DOT DOT STRING .)
    RAT             reduce using rule 71 (range -> STRING DOT DOT STRING .)
    COMPX           reduce using rule 71 (range -> STRING DOT DOT STRING .)
    COLON           reduce using rule 71 (range -> STRING DOT DOT STRING .)
    WHEN            reduce using rule 71 (range -> STRING DOT DOT STRING .)
    THEN            reduce using rule 71 (range -> STRING DOT DOT STRING .)


state 106

    (69) range -> INT DOT DOT INT .

    EQCOMP          reduce using rule 69 (range -> INT DOT DOT INT .)
    LESSTH          reduce using rule 69 (range -> INT DOT DOT INT .)
    LESSEQTH        reduce using rule 69 (range -> INT DOT DOT INT .)
    GREATH          reduce using rule 69 (range -> INT DOT DOT INT .)
    GREATEQTH       reduce using rule 69 (range -> INT DOT DOT INT .)
    NOTEQ           reduce using rule 69 (range -> INT DOT DOT INT .)
    $end            reduce using rule 69 (range -> INT DOT DOT INT .)
    END             reduce using rule 69 (range -> INT DOT DOT INT .)
    RETURN          reduce using rule 69 (range -> INT DOT DOT INT .)
    ELSE            reduce using rule 69 (range -> INT DOT DOT INT .)
    ELSIF           reduce using rule 69 (range -> INT DOT DOT INT .)
    COMMA           reduce using rule 69 (range -> INT DOT DOT INT .)
    RPAREN          reduce using rule 69 (range -> INT DOT DOT INT .)
    ID              reduce using rule 69 (range -> INT DOT DOT INT .)
    DEF             reduce using rule 69 (range -> INT DOT DOT INT .)
    IF              reduce using rule 69 (range -> INT DOT DOT INT .)
    UNLESS          reduce using rule 69 (range -> INT DOT DOT INT .)
    CASE            reduce using rule 69 (range -> INT DOT DOT INT .)
    INT             reduce using rule 69 (range -> INT DOT DOT INT .)
    FLOAT           reduce using rule 69 (range -> INT DOT DOT INT .)
    RAT             reduce using rule 69 (range -> INT DOT DOT INT .)
    COMPX           reduce using rule 69 (range -> INT DOT DOT INT .)
    COLON           reduce using rule 69 (range -> INT DOT DOT INT .)
    WHEN            reduce using rule 69 (range -> INT DOT DOT INT .)
    THEN            reduce using rule 69 (range -> INT DOT DOT INT .)


state 107

    (68) range -> LPAREN INT DOT DOT . INT RPAREN

    INT             shift and go to state 124


state 108

    (70) range -> LPAREN STRING DOT DOT . STRING

    STRING          shift and go to state 125


state 109

    (41) control -> UNLESS comptn COLON cmmd END .

    $end            reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    END             reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    RETURN          reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    ELSE            reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    ELSIF           reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)


state 110

    (43) control -> UNLESS comptn cmmd elses END .

    $end            reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    END             reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    RETURN          reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    ELSE            reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    ELSIF           reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)


state 111

    (42) control -> UNLESS bool COLON cmmd END .

    $end            reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    END             reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    RETURN          reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    ELSE            reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    ELSIF           reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)


state 112

    (44) control -> UNLESS bool cmmd elses END .

    $end            reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    END             reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    RETURN          reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    ELSE            reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    ELSIF           reduce using rule 44 (control -> UNLESS bool cmmd elses END .)


state 113

    (50) control -> CASE ID whens else END .

    $end            reduce using rule 50 (control -> CASE ID whens else END .)
    END             reduce using rule 50 (control -> CASE ID whens else END .)
    RETURN          reduce using rule 50 (control -> CASE ID whens else END .)
    ELSE            reduce using rule 50 (control -> CASE ID whens else END .)
    ELSIF           reduce using rule 50 (control -> CASE ID whens else END .)


state 114

    (46) when -> WHEN objs THEN .

    WHEN            reduce using rule 46 (when -> WHEN objs THEN .)
    END             reduce using rule 46 (when -> WHEN objs THEN .)
    ELSE            reduce using rule 46 (when -> WHEN objs THEN .)


state 115

    (25) func -> DEF ID LPAREN objs RPAREN cmmd . END
    (28) func -> DEF ID LPAREN objs RPAREN cmmd . RETURN obj END

    END             shift and go to state 126
    RETURN          shift and go to state 127


state 116

    (26) func -> DEF ID LPAREN RPAREN cmmd END .

    $end            reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    END             reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    RETURN          reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    ELSE            reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    ELSIF           reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)


state 117

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN . obj END
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    obj                            shift and go to state 128
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 118

    (63) objs -> obj COMMA objs .

    RPAREN          reduce using rule 63 (objs -> obj COMMA objs .)
    THEN            reduce using rule 63 (objs -> obj COMMA objs .)
    WHEN            reduce using rule 63 (objs -> obj COMMA objs .)
    END             reduce using rule 63 (objs -> obj COMMA objs .)
    ELSE            reduce using rule 63 (objs -> obj COMMA objs .)


state 119

    (30) func -> DEF ID cmmd RETURN obj END .

    $end            reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    END             reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    RETURN          reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    ELSE            reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    ELSIF           reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)


state 120

    (31) else -> ELSE comptn cmmd .

    END             reduce using rule 31 (else -> ELSE comptn cmmd .)


state 121

    (32) else -> ELSE bool cmmd .

    END             reduce using rule 32 (else -> ELSE bool cmmd .)


state 122

    (33) elsif -> ELSIF comptn cmmd .

    ELSE            reduce using rule 33 (elsif -> ELSIF comptn cmmd .)
    ELSIF           reduce using rule 33 (elsif -> ELSIF comptn cmmd .)


state 123

    (34) elsif -> ELSIF bool cmmd .

    ELSE            reduce using rule 34 (elsif -> ELSIF bool cmmd .)
    ELSIF           reduce using rule 34 (elsif -> ELSIF bool cmmd .)


state 124

    (68) range -> LPAREN INT DOT DOT INT . RPAREN

    RPAREN          shift and go to state 129


state 125

    (70) range -> LPAREN STRING DOT DOT STRING .

    EQCOMP          reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    LESSTH          reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    LESSEQTH        reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    GREATH          reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    GREATEQTH       reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    NOTEQ           reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    $end            reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    END             reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    RETURN          reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    ELSE            reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    ELSIF           reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    COMMA           reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    RPAREN          reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    ID              reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    DEF             reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    IF              reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    UNLESS          reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    CASE            reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    INT             reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    FLOAT           reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    RAT             reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    COMPX           reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    COLON           reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    WHEN            reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)
    THEN            reduce using rule 70 (range -> LPAREN STRING DOT DOT STRING .)


state 126

    (25) func -> DEF ID LPAREN objs RPAREN cmmd END .

    $end            reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    END             reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    RETURN          reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    ELSE            reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    ELSIF           reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)


state 127

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN . obj END
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (68) range -> . LPAREN INT DOT DOT INT RPAREN
    (69) range -> . INT DOT DOT INT
    (70) range -> . LPAREN STRING DOT DOT STRING
    (71) range -> . STRING DOT DOT STRING

    STRING          shift and go to state 24
    INT             shift and go to state 27
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 28

    obj                            shift and go to state 130
    num                            shift and go to state 25
    bool                           shift and go to state 42
    range                          shift and go to state 26

state 128

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN obj . END

    END             shift and go to state 131


state 129

    (68) range -> LPAREN INT DOT DOT INT RPAREN .

    EQCOMP          reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    LESSTH          reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    LESSEQTH        reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    GREATH          reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    GREATEQTH       reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    NOTEQ           reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    $end            reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    END             reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RETURN          reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ELSE            reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ELSIF           reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COMMA           reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RPAREN          reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ID              reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    DEF             reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    IF              reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    UNLESS          reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    CASE            reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    INT             reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    FLOAT           reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RAT             reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COMPX           reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COLON           reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    WHEN            reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)
    THEN            reduce using rule 68 (range -> LPAREN INT DOT DOT INT RPAREN .)


state 130

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj . END

    END             shift and go to state 132


state 131

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .

    $end            reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    END             reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    RETURN          reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    ELSE            reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    ELSIF           reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)


state 132

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .

    $end            reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    END             reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    RETURN          reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    ELSE            reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    ELSIF           reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)

