Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERS
    AND
    ARRAY
    AT
    BEGIN
    BOOLAND
    BOOLOR
    BREAK
    CLASS
    COMMENT
    DOLLARSGN
    DUODOT
    ENSURE
    FOR
    IN
    MINUSEQ
    NEXT
    NOT
    OR
    PIPE
    PLUSEQ
    RETRY
    SELF
    SEMICOLON
    SUPER
    TILDE
    TRIDOT
    UNDERSCR
    UNTIL

Grammar

Rule 0     S' -> init
Rule 1     init -> cmmd
Rule 2     bool -> TRUE
Rule 3     bool -> FALSE
Rule 4     num -> INT
Rule 5     num -> FLOAT
Rule 6     num -> RAT
Rule 7     num -> COMPX
Rule 8     optr -> PLUS
Rule 9     optr -> MINUS
Rule 10    optr -> TIMES
Rule 11    optr -> DIVIDE
Rule 12    optr -> MODULE
Rule 13    optr -> EXPON
Rule 14    optn -> num optr num
Rule 15    comptn -> obj comptr obj
Rule 16    comptr -> EQCOMP
Rule 17    comptr -> LESSTH
Rule 18    comptr -> LESSEQTH
Rule 19    comptr -> GREATH
Rule 20    comptr -> GREATEQTH
Rule 21    comptr -> NOTEQ
Rule 22    var -> ID EQUALS obj
Rule 23    var -> ID EQUALS ID
Rule 24    var -> ID EQUALS NIL
Rule 25    func -> DEF ID LPAREN objs RPAREN cmmd END
Rule 26    func -> DEF ID LPAREN RPAREN cmmd END
Rule 27    func -> DEF ID cmmd END
Rule 28    func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END
Rule 29    func -> DEF ID LPAREN RPAREN cmmd RETURN obj END
Rule 30    func -> DEF ID cmmd RETURN obj END
Rule 31    else -> ELSE comptn cmmd
Rule 32    else -> ELSE bool cmmd
Rule 33    elsif -> ELSIF comptn cmmd
Rule 34    elsif -> ELSIF bool cmmd
Rule 35    elses -> else
Rule 36    elses -> elsif elses
Rule 37    control -> IF comptn cmmd END
Rule 38    control -> IF bool cmmd END
Rule 39    control -> IF comptn cmmd elses END
Rule 40    control -> IF bool cmmd elses END
Rule 41    control -> UNLESS comptn COLON cmmd END
Rule 42    control -> UNLESS bool COLON cmmd END
Rule 43    control -> UNLESS comptn cmmd elses END
Rule 44    control -> UNLESS bool cmmd elses END
Rule 45    when -> WHEN objs
Rule 46    when -> WHEN objs THEN
Rule 47    when -> WHEN comptn
Rule 48    whens -> when
Rule 49    whens -> when whens
Rule 50    control -> CASE ID whens else END
Rule 51    control -> CASE ID whens END
Rule 52    ids -> ID
Rule 53    ids -> ID COMMA ids
Rule 54    array -> LBRAKET objs RBRAKET
Rule 55    array -> LBRAKET ids RBRAKET
Rule 56    array -> LBRAKET objs COMMA ids RBRAKET
Rule 57    array -> LBRAKET ids COMMA objs RBRAKET
Rule 58    strucSet -> SET DOT NEW
Rule 59    strucSet -> SET DOT NEW LPAREN RPAREN
Rule 60    strucSet -> SET DOT NEW LPAREN array RPAREN
Rule 61    strucSet -> SET array
Rule 62    claveHash -> STRING
Rule 63    claveHash -> num
Rule 64    claveHash -> bool
Rule 65    claveHash -> range
Rule 66    claveHash -> matrix
Rule 67    elementHash -> claveHash ROCKET obj
Rule 68    elementsHash -> elementHash COMMA elementHash
Rule 69    elementsHash -> elementHash COMMA elementsHash
Rule 70    hash -> LBRACE elementsHash RBRACE
Rule 71    control -> WHILE comptn DO cmmd END
Rule 72    control -> WHILE bool DO cmmd END
Rule 73    objs -> obj
Rule 74    objs -> obj COMMA objs
Rule 75    obj -> STRING
Rule 76    obj -> num
Rule 77    obj -> bool
Rule 78    obj -> range
Rule 79    obj -> matrix
Rule 80    obj -> hash
Rule 81    obj -> strucSet
Rule 82    range -> LPAREN INT DOT DOT INT RPAREN
Rule 83    range -> INT DOT DOT INT
Rule 84    range -> LPAREN STRING DOT DOT STRING
Rule 85    range -> STRING DOT DOT STRING
Rule 86    cmmd -> var
Rule 87    cmmd -> func
Rule 88    cmmd -> control
Rule 89    cmmd -> optn
Rule 90    matrix -> LBRAKET rows RBRAKET
Rule 91    rows -> row
Rule 92    rows -> row COMMA rows
Rule 93    row -> array

Terminals, with rules where they appear

AMPERS               : 
AND                  : 
ARRAY                : 
AT                   : 
BEGIN                : 
BOOLAND              : 
BOOLOR               : 
BREAK                : 
CASE                 : 50 51
CLASS                : 
COLON                : 41 42
COMMA                : 53 56 57 68 69 74 92
COMMENT              : 
COMPX                : 7
DEF                  : 25 26 27 28 29 30
DIVIDE               : 11
DO                   : 71 72
DOLLARSGN            : 
DOT                  : 58 59 60 82 82 83 83 84 84 85 85
DUODOT               : 
ELSE                 : 31 32
ELSIF                : 33 34
END                  : 25 26 27 28 29 30 37 38 39 40 41 42 43 44 50 51 71 72
ENSURE               : 
EQCOMP               : 16
EQUALS               : 22 23 24
EXPON                : 13
FALSE                : 3
FLOAT                : 5
FOR                  : 
GREATEQTH            : 20
GREATH               : 19
ID                   : 22 23 23 24 25 26 27 28 29 30 50 51 52 53
IF                   : 37 38 39 40
IN                   : 
INT                  : 4 82 82 83 83
LBRACE               : 70
LBRAKET              : 54 55 56 57 90
LESSEQTH             : 18
LESSTH               : 17
LPAREN               : 25 26 28 29 59 60 82 84
MINUS                : 9
MINUSEQ              : 
MODULE               : 12
NEW                  : 58 59 60
NEXT                 : 
NIL                  : 24
NOT                  : 
NOTEQ                : 21
OR                   : 
PIPE                 : 
PLUS                 : 8
PLUSEQ               : 
RAT                  : 6
RBRACE               : 70
RBRAKET              : 54 55 56 57 90
RETRY                : 
RETURN               : 28 29 30
ROCKET               : 67
RPAREN               : 25 26 28 29 59 60 82
SELF                 : 
SEMICOLON            : 
SET                  : 58 59 60 61
STRING               : 62 75 84 84 85 85
SUPER                : 
THEN                 : 46
TILDE                : 
TIMES                : 10
TRIDOT               : 
TRUE                 : 2
UNDERSCR             : 
UNLESS               : 41 42 43 44
UNTIL                : 
WHEN                 : 45 46 47
WHILE                : 71 72
error                : 

Nonterminals, with rules where they appear

array                : 60 61 93
bool                 : 32 34 38 40 42 44 64 72 77
claveHash            : 67
cmmd                 : 1 25 26 27 28 29 30 31 32 33 34 37 38 39 40 41 42 43 44 71 72
comptn               : 31 33 37 39 41 43 47 71
comptr               : 15
control              : 88
elementHash          : 68 68 69
elementsHash         : 69 70
else                 : 35 50
elses                : 36 39 40 43 44
elsif                : 36
func                 : 87
hash                 : 80
ids                  : 53 55 56 57
init                 : 0
matrix               : 66 79
num                  : 14 14 63 76
obj                  : 15 15 22 28 29 30 67 73 74
objs                 : 25 28 45 46 54 56 57 74
optn                 : 89
optr                 : 14
range                : 65 78
row                  : 91 92
rows                 : 90 92
strucSet             : 81
var                  : 86
when                 : 48 49
whens                : 49 50 51

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . cmmd
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    init                           shift and go to state 1
    cmmd                           shift and go to state 2
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 1

    (0) S' -> init .



state 2

    (1) init -> cmmd .

    $end            reduce using rule 1 (init -> cmmd .)


state 3

    (86) cmmd -> var .

    $end            reduce using rule 86 (cmmd -> var .)
    END             reduce using rule 86 (cmmd -> var .)
    RETURN          reduce using rule 86 (cmmd -> var .)
    ELSE            reduce using rule 86 (cmmd -> var .)
    ELSIF           reduce using rule 86 (cmmd -> var .)


state 4

    (87) cmmd -> func .

    $end            reduce using rule 87 (cmmd -> func .)
    END             reduce using rule 87 (cmmd -> func .)
    RETURN          reduce using rule 87 (cmmd -> func .)
    ELSE            reduce using rule 87 (cmmd -> func .)
    ELSIF           reduce using rule 87 (cmmd -> func .)


state 5

    (88) cmmd -> control .

    $end            reduce using rule 88 (cmmd -> control .)
    END             reduce using rule 88 (cmmd -> control .)
    RETURN          reduce using rule 88 (cmmd -> control .)
    ELSE            reduce using rule 88 (cmmd -> control .)
    ELSIF           reduce using rule 88 (cmmd -> control .)


state 6

    (89) cmmd -> optn .

    $end            reduce using rule 89 (cmmd -> optn .)
    END             reduce using rule 89 (cmmd -> optn .)
    RETURN          reduce using rule 89 (cmmd -> optn .)
    ELSE            reduce using rule 89 (cmmd -> optn .)
    ELSIF           reduce using rule 89 (cmmd -> optn .)


state 7

    (22) var -> ID . EQUALS obj
    (23) var -> ID . EQUALS ID
    (24) var -> ID . EQUALS NIL

    EQUALS          shift and go to state 18


state 8

    (25) func -> DEF . ID LPAREN objs RPAREN cmmd END
    (26) func -> DEF . ID LPAREN RPAREN cmmd END
    (27) func -> DEF . ID cmmd END
    (28) func -> DEF . ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> DEF . ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> DEF . ID cmmd RETURN obj END

    ID              shift and go to state 19


state 9

    (37) control -> IF . comptn cmmd END
    (38) control -> IF . bool cmmd END
    (39) control -> IF . comptn cmmd elses END
    (40) control -> IF . bool cmmd elses END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    comptn                         shift and go to state 20
    bool                           shift and go to state 21
    obj                            shift and go to state 22
    num                            shift and go to state 26
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 10

    (41) control -> UNLESS . comptn COLON cmmd END
    (42) control -> UNLESS . bool COLON cmmd END
    (43) control -> UNLESS . comptn cmmd elses END
    (44) control -> UNLESS . bool cmmd elses END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    comptn                         shift and go to state 36
    bool                           shift and go to state 37
    obj                            shift and go to state 22
    num                            shift and go to state 26
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 11

    (50) control -> CASE . ID whens else END
    (51) control -> CASE . ID whens END

    ID              shift and go to state 38


state 12

    (71) control -> WHILE . comptn DO cmmd END
    (72) control -> WHILE . bool DO cmmd END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    comptn                         shift and go to state 39
    bool                           shift and go to state 40
    obj                            shift and go to state 22
    num                            shift and go to state 26
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 13

    (14) optn -> num . optr num
    (8) optr -> . PLUS
    (9) optr -> . MINUS
    (10) optr -> . TIMES
    (11) optr -> . DIVIDE
    (12) optr -> . MODULE
    (13) optr -> . EXPON

    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    TIMES           shift and go to state 44
    DIVIDE          shift and go to state 45
    MODULE          shift and go to state 46
    EXPON           shift and go to state 47

    optr                           shift and go to state 41

state 14

    (4) num -> INT .

    PLUS            reduce using rule 4 (num -> INT .)
    MINUS           reduce using rule 4 (num -> INT .)
    TIMES           reduce using rule 4 (num -> INT .)
    DIVIDE          reduce using rule 4 (num -> INT .)
    MODULE          reduce using rule 4 (num -> INT .)
    EXPON           reduce using rule 4 (num -> INT .)
    $end            reduce using rule 4 (num -> INT .)
    END             reduce using rule 4 (num -> INT .)
    RETURN          reduce using rule 4 (num -> INT .)
    ELSE            reduce using rule 4 (num -> INT .)
    ELSIF           reduce using rule 4 (num -> INT .)


state 15

    (5) num -> FLOAT .

    PLUS            reduce using rule 5 (num -> FLOAT .)
    MINUS           reduce using rule 5 (num -> FLOAT .)
    TIMES           reduce using rule 5 (num -> FLOAT .)
    DIVIDE          reduce using rule 5 (num -> FLOAT .)
    MODULE          reduce using rule 5 (num -> FLOAT .)
    EXPON           reduce using rule 5 (num -> FLOAT .)
    EQCOMP          reduce using rule 5 (num -> FLOAT .)
    LESSTH          reduce using rule 5 (num -> FLOAT .)
    LESSEQTH        reduce using rule 5 (num -> FLOAT .)
    GREATH          reduce using rule 5 (num -> FLOAT .)
    GREATEQTH       reduce using rule 5 (num -> FLOAT .)
    NOTEQ           reduce using rule 5 (num -> FLOAT .)
    $end            reduce using rule 5 (num -> FLOAT .)
    END             reduce using rule 5 (num -> FLOAT .)
    RETURN          reduce using rule 5 (num -> FLOAT .)
    ELSE            reduce using rule 5 (num -> FLOAT .)
    ELSIF           reduce using rule 5 (num -> FLOAT .)
    ROCKET          reduce using rule 5 (num -> FLOAT .)
    COMMA           reduce using rule 5 (num -> FLOAT .)
    RPAREN          reduce using rule 5 (num -> FLOAT .)
    ID              reduce using rule 5 (num -> FLOAT .)
    DEF             reduce using rule 5 (num -> FLOAT .)
    IF              reduce using rule 5 (num -> FLOAT .)
    UNLESS          reduce using rule 5 (num -> FLOAT .)
    CASE            reduce using rule 5 (num -> FLOAT .)
    WHILE           reduce using rule 5 (num -> FLOAT .)
    INT             reduce using rule 5 (num -> FLOAT .)
    FLOAT           reduce using rule 5 (num -> FLOAT .)
    RAT             reduce using rule 5 (num -> FLOAT .)
    COMPX           reduce using rule 5 (num -> FLOAT .)
    COLON           reduce using rule 5 (num -> FLOAT .)
    DO              reduce using rule 5 (num -> FLOAT .)
    WHEN            reduce using rule 5 (num -> FLOAT .)
    RBRAKET         reduce using rule 5 (num -> FLOAT .)
    THEN            reduce using rule 5 (num -> FLOAT .)
    RBRACE          reduce using rule 5 (num -> FLOAT .)


state 16

    (6) num -> RAT .

    PLUS            reduce using rule 6 (num -> RAT .)
    MINUS           reduce using rule 6 (num -> RAT .)
    TIMES           reduce using rule 6 (num -> RAT .)
    DIVIDE          reduce using rule 6 (num -> RAT .)
    MODULE          reduce using rule 6 (num -> RAT .)
    EXPON           reduce using rule 6 (num -> RAT .)
    EQCOMP          reduce using rule 6 (num -> RAT .)
    LESSTH          reduce using rule 6 (num -> RAT .)
    LESSEQTH        reduce using rule 6 (num -> RAT .)
    GREATH          reduce using rule 6 (num -> RAT .)
    GREATEQTH       reduce using rule 6 (num -> RAT .)
    NOTEQ           reduce using rule 6 (num -> RAT .)
    $end            reduce using rule 6 (num -> RAT .)
    END             reduce using rule 6 (num -> RAT .)
    RETURN          reduce using rule 6 (num -> RAT .)
    ELSE            reduce using rule 6 (num -> RAT .)
    ELSIF           reduce using rule 6 (num -> RAT .)
    ROCKET          reduce using rule 6 (num -> RAT .)
    COMMA           reduce using rule 6 (num -> RAT .)
    RPAREN          reduce using rule 6 (num -> RAT .)
    ID              reduce using rule 6 (num -> RAT .)
    DEF             reduce using rule 6 (num -> RAT .)
    IF              reduce using rule 6 (num -> RAT .)
    UNLESS          reduce using rule 6 (num -> RAT .)
    CASE            reduce using rule 6 (num -> RAT .)
    WHILE           reduce using rule 6 (num -> RAT .)
    INT             reduce using rule 6 (num -> RAT .)
    FLOAT           reduce using rule 6 (num -> RAT .)
    RAT             reduce using rule 6 (num -> RAT .)
    COMPX           reduce using rule 6 (num -> RAT .)
    COLON           reduce using rule 6 (num -> RAT .)
    DO              reduce using rule 6 (num -> RAT .)
    WHEN            reduce using rule 6 (num -> RAT .)
    RBRAKET         reduce using rule 6 (num -> RAT .)
    THEN            reduce using rule 6 (num -> RAT .)
    RBRACE          reduce using rule 6 (num -> RAT .)


state 17

    (7) num -> COMPX .

    PLUS            reduce using rule 7 (num -> COMPX .)
    MINUS           reduce using rule 7 (num -> COMPX .)
    TIMES           reduce using rule 7 (num -> COMPX .)
    DIVIDE          reduce using rule 7 (num -> COMPX .)
    MODULE          reduce using rule 7 (num -> COMPX .)
    EXPON           reduce using rule 7 (num -> COMPX .)
    EQCOMP          reduce using rule 7 (num -> COMPX .)
    LESSTH          reduce using rule 7 (num -> COMPX .)
    LESSEQTH        reduce using rule 7 (num -> COMPX .)
    GREATH          reduce using rule 7 (num -> COMPX .)
    GREATEQTH       reduce using rule 7 (num -> COMPX .)
    NOTEQ           reduce using rule 7 (num -> COMPX .)
    $end            reduce using rule 7 (num -> COMPX .)
    END             reduce using rule 7 (num -> COMPX .)
    RETURN          reduce using rule 7 (num -> COMPX .)
    ELSE            reduce using rule 7 (num -> COMPX .)
    ELSIF           reduce using rule 7 (num -> COMPX .)
    ROCKET          reduce using rule 7 (num -> COMPX .)
    COMMA           reduce using rule 7 (num -> COMPX .)
    RPAREN          reduce using rule 7 (num -> COMPX .)
    ID              reduce using rule 7 (num -> COMPX .)
    DEF             reduce using rule 7 (num -> COMPX .)
    IF              reduce using rule 7 (num -> COMPX .)
    UNLESS          reduce using rule 7 (num -> COMPX .)
    CASE            reduce using rule 7 (num -> COMPX .)
    WHILE           reduce using rule 7 (num -> COMPX .)
    INT             reduce using rule 7 (num -> COMPX .)
    FLOAT           reduce using rule 7 (num -> COMPX .)
    RAT             reduce using rule 7 (num -> COMPX .)
    COMPX           reduce using rule 7 (num -> COMPX .)
    COLON           reduce using rule 7 (num -> COMPX .)
    DO              reduce using rule 7 (num -> COMPX .)
    WHEN            reduce using rule 7 (num -> COMPX .)
    RBRAKET         reduce using rule 7 (num -> COMPX .)
    THEN            reduce using rule 7 (num -> COMPX .)
    RBRACE          reduce using rule 7 (num -> COMPX .)


state 18

    (22) var -> ID EQUALS . obj
    (23) var -> ID EQUALS . ID
    (24) var -> ID EQUALS . NIL
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    ID              shift and go to state 48
    NIL             shift and go to state 50
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 49
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 19

    (25) func -> DEF ID . LPAREN objs RPAREN cmmd END
    (26) func -> DEF ID . LPAREN RPAREN cmmd END
    (27) func -> DEF ID . cmmd END
    (28) func -> DEF ID . LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> DEF ID . LPAREN RPAREN cmmd RETURN obj END
    (30) func -> DEF ID . cmmd RETURN obj END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    LPAREN          shift and go to state 52
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 53
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 20

    (37) control -> IF comptn . cmmd END
    (39) control -> IF comptn . cmmd elses END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 54
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 21

    (38) control -> IF bool . cmmd END
    (40) control -> IF bool . cmmd elses END
    (77) obj -> bool .
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 77 (obj -> bool .)
    LESSTH          reduce using rule 77 (obj -> bool .)
    LESSEQTH        reduce using rule 77 (obj -> bool .)
    GREATH          reduce using rule 77 (obj -> bool .)
    GREATEQTH       reduce using rule 77 (obj -> bool .)
    NOTEQ           reduce using rule 77 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 55
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 22

    (15) comptn -> obj . comptr obj
    (16) comptr -> . EQCOMP
    (17) comptr -> . LESSTH
    (18) comptr -> . LESSEQTH
    (19) comptr -> . GREATH
    (20) comptr -> . GREATEQTH
    (21) comptr -> . NOTEQ

    EQCOMP          shift and go to state 57
    LESSTH          shift and go to state 58
    LESSEQTH        shift and go to state 59
    GREATH          shift and go to state 60
    GREATEQTH       shift and go to state 61
    NOTEQ           shift and go to state 62

    comptr                         shift and go to state 56

state 23

    (2) bool -> TRUE .

    ID              reduce using rule 2 (bool -> TRUE .)
    DEF             reduce using rule 2 (bool -> TRUE .)
    IF              reduce using rule 2 (bool -> TRUE .)
    UNLESS          reduce using rule 2 (bool -> TRUE .)
    CASE            reduce using rule 2 (bool -> TRUE .)
    WHILE           reduce using rule 2 (bool -> TRUE .)
    INT             reduce using rule 2 (bool -> TRUE .)
    FLOAT           reduce using rule 2 (bool -> TRUE .)
    RAT             reduce using rule 2 (bool -> TRUE .)
    COMPX           reduce using rule 2 (bool -> TRUE .)
    EQCOMP          reduce using rule 2 (bool -> TRUE .)
    LESSTH          reduce using rule 2 (bool -> TRUE .)
    LESSEQTH        reduce using rule 2 (bool -> TRUE .)
    GREATH          reduce using rule 2 (bool -> TRUE .)
    GREATEQTH       reduce using rule 2 (bool -> TRUE .)
    NOTEQ           reduce using rule 2 (bool -> TRUE .)
    COLON           reduce using rule 2 (bool -> TRUE .)
    DO              reduce using rule 2 (bool -> TRUE .)
    $end            reduce using rule 2 (bool -> TRUE .)
    END             reduce using rule 2 (bool -> TRUE .)
    RETURN          reduce using rule 2 (bool -> TRUE .)
    ELSE            reduce using rule 2 (bool -> TRUE .)
    ELSIF           reduce using rule 2 (bool -> TRUE .)
    ROCKET          reduce using rule 2 (bool -> TRUE .)
    COMMA           reduce using rule 2 (bool -> TRUE .)
    RPAREN          reduce using rule 2 (bool -> TRUE .)
    WHEN            reduce using rule 2 (bool -> TRUE .)
    RBRAKET         reduce using rule 2 (bool -> TRUE .)
    THEN            reduce using rule 2 (bool -> TRUE .)
    RBRACE          reduce using rule 2 (bool -> TRUE .)


state 24

    (3) bool -> FALSE .

    ID              reduce using rule 3 (bool -> FALSE .)
    DEF             reduce using rule 3 (bool -> FALSE .)
    IF              reduce using rule 3 (bool -> FALSE .)
    UNLESS          reduce using rule 3 (bool -> FALSE .)
    CASE            reduce using rule 3 (bool -> FALSE .)
    WHILE           reduce using rule 3 (bool -> FALSE .)
    INT             reduce using rule 3 (bool -> FALSE .)
    FLOAT           reduce using rule 3 (bool -> FALSE .)
    RAT             reduce using rule 3 (bool -> FALSE .)
    COMPX           reduce using rule 3 (bool -> FALSE .)
    EQCOMP          reduce using rule 3 (bool -> FALSE .)
    LESSTH          reduce using rule 3 (bool -> FALSE .)
    LESSEQTH        reduce using rule 3 (bool -> FALSE .)
    GREATH          reduce using rule 3 (bool -> FALSE .)
    GREATEQTH       reduce using rule 3 (bool -> FALSE .)
    NOTEQ           reduce using rule 3 (bool -> FALSE .)
    COLON           reduce using rule 3 (bool -> FALSE .)
    DO              reduce using rule 3 (bool -> FALSE .)
    $end            reduce using rule 3 (bool -> FALSE .)
    END             reduce using rule 3 (bool -> FALSE .)
    RETURN          reduce using rule 3 (bool -> FALSE .)
    ELSE            reduce using rule 3 (bool -> FALSE .)
    ELSIF           reduce using rule 3 (bool -> FALSE .)
    ROCKET          reduce using rule 3 (bool -> FALSE .)
    COMMA           reduce using rule 3 (bool -> FALSE .)
    RPAREN          reduce using rule 3 (bool -> FALSE .)
    WHEN            reduce using rule 3 (bool -> FALSE .)
    RBRAKET         reduce using rule 3 (bool -> FALSE .)
    THEN            reduce using rule 3 (bool -> FALSE .)
    RBRACE          reduce using rule 3 (bool -> FALSE .)


state 25

    (75) obj -> STRING .
    (85) range -> STRING . DOT DOT STRING

    EQCOMP          reduce using rule 75 (obj -> STRING .)
    LESSTH          reduce using rule 75 (obj -> STRING .)
    LESSEQTH        reduce using rule 75 (obj -> STRING .)
    GREATH          reduce using rule 75 (obj -> STRING .)
    GREATEQTH       reduce using rule 75 (obj -> STRING .)
    NOTEQ           reduce using rule 75 (obj -> STRING .)
    $end            reduce using rule 75 (obj -> STRING .)
    END             reduce using rule 75 (obj -> STRING .)
    RETURN          reduce using rule 75 (obj -> STRING .)
    ELSE            reduce using rule 75 (obj -> STRING .)
    ELSIF           reduce using rule 75 (obj -> STRING .)
    COMMA           reduce using rule 75 (obj -> STRING .)
    RPAREN          reduce using rule 75 (obj -> STRING .)
    ID              reduce using rule 75 (obj -> STRING .)
    DEF             reduce using rule 75 (obj -> STRING .)
    IF              reduce using rule 75 (obj -> STRING .)
    UNLESS          reduce using rule 75 (obj -> STRING .)
    CASE            reduce using rule 75 (obj -> STRING .)
    WHILE           reduce using rule 75 (obj -> STRING .)
    INT             reduce using rule 75 (obj -> STRING .)
    FLOAT           reduce using rule 75 (obj -> STRING .)
    RAT             reduce using rule 75 (obj -> STRING .)
    COMPX           reduce using rule 75 (obj -> STRING .)
    COLON           reduce using rule 75 (obj -> STRING .)
    DO              reduce using rule 75 (obj -> STRING .)
    WHEN            reduce using rule 75 (obj -> STRING .)
    RBRAKET         reduce using rule 75 (obj -> STRING .)
    THEN            reduce using rule 75 (obj -> STRING .)
    RBRACE          reduce using rule 75 (obj -> STRING .)
    DOT             shift and go to state 63


state 26

    (76) obj -> num .

    EQCOMP          reduce using rule 76 (obj -> num .)
    LESSTH          reduce using rule 76 (obj -> num .)
    LESSEQTH        reduce using rule 76 (obj -> num .)
    GREATH          reduce using rule 76 (obj -> num .)
    GREATEQTH       reduce using rule 76 (obj -> num .)
    NOTEQ           reduce using rule 76 (obj -> num .)
    $end            reduce using rule 76 (obj -> num .)
    END             reduce using rule 76 (obj -> num .)
    RETURN          reduce using rule 76 (obj -> num .)
    ELSE            reduce using rule 76 (obj -> num .)
    ELSIF           reduce using rule 76 (obj -> num .)
    COMMA           reduce using rule 76 (obj -> num .)
    RPAREN          reduce using rule 76 (obj -> num .)
    ID              reduce using rule 76 (obj -> num .)
    DEF             reduce using rule 76 (obj -> num .)
    IF              reduce using rule 76 (obj -> num .)
    UNLESS          reduce using rule 76 (obj -> num .)
    CASE            reduce using rule 76 (obj -> num .)
    WHILE           reduce using rule 76 (obj -> num .)
    INT             reduce using rule 76 (obj -> num .)
    FLOAT           reduce using rule 76 (obj -> num .)
    RAT             reduce using rule 76 (obj -> num .)
    COMPX           reduce using rule 76 (obj -> num .)
    COLON           reduce using rule 76 (obj -> num .)
    DO              reduce using rule 76 (obj -> num .)
    WHEN            reduce using rule 76 (obj -> num .)
    RBRAKET         reduce using rule 76 (obj -> num .)
    THEN            reduce using rule 76 (obj -> num .)
    RBRACE          reduce using rule 76 (obj -> num .)


state 27

    (78) obj -> range .

    EQCOMP          reduce using rule 78 (obj -> range .)
    LESSTH          reduce using rule 78 (obj -> range .)
    LESSEQTH        reduce using rule 78 (obj -> range .)
    GREATH          reduce using rule 78 (obj -> range .)
    GREATEQTH       reduce using rule 78 (obj -> range .)
    NOTEQ           reduce using rule 78 (obj -> range .)
    $end            reduce using rule 78 (obj -> range .)
    END             reduce using rule 78 (obj -> range .)
    RETURN          reduce using rule 78 (obj -> range .)
    ELSE            reduce using rule 78 (obj -> range .)
    ELSIF           reduce using rule 78 (obj -> range .)
    COMMA           reduce using rule 78 (obj -> range .)
    RPAREN          reduce using rule 78 (obj -> range .)
    ID              reduce using rule 78 (obj -> range .)
    DEF             reduce using rule 78 (obj -> range .)
    IF              reduce using rule 78 (obj -> range .)
    UNLESS          reduce using rule 78 (obj -> range .)
    CASE            reduce using rule 78 (obj -> range .)
    WHILE           reduce using rule 78 (obj -> range .)
    INT             reduce using rule 78 (obj -> range .)
    FLOAT           reduce using rule 78 (obj -> range .)
    RAT             reduce using rule 78 (obj -> range .)
    COMPX           reduce using rule 78 (obj -> range .)
    COLON           reduce using rule 78 (obj -> range .)
    DO              reduce using rule 78 (obj -> range .)
    WHEN            reduce using rule 78 (obj -> range .)
    RBRAKET         reduce using rule 78 (obj -> range .)
    THEN            reduce using rule 78 (obj -> range .)
    RBRACE          reduce using rule 78 (obj -> range .)


state 28

    (79) obj -> matrix .

    EQCOMP          reduce using rule 79 (obj -> matrix .)
    LESSTH          reduce using rule 79 (obj -> matrix .)
    LESSEQTH        reduce using rule 79 (obj -> matrix .)
    GREATH          reduce using rule 79 (obj -> matrix .)
    GREATEQTH       reduce using rule 79 (obj -> matrix .)
    NOTEQ           reduce using rule 79 (obj -> matrix .)
    $end            reduce using rule 79 (obj -> matrix .)
    END             reduce using rule 79 (obj -> matrix .)
    RETURN          reduce using rule 79 (obj -> matrix .)
    ELSE            reduce using rule 79 (obj -> matrix .)
    ELSIF           reduce using rule 79 (obj -> matrix .)
    COMMA           reduce using rule 79 (obj -> matrix .)
    RPAREN          reduce using rule 79 (obj -> matrix .)
    ID              reduce using rule 79 (obj -> matrix .)
    DEF             reduce using rule 79 (obj -> matrix .)
    IF              reduce using rule 79 (obj -> matrix .)
    UNLESS          reduce using rule 79 (obj -> matrix .)
    CASE            reduce using rule 79 (obj -> matrix .)
    WHILE           reduce using rule 79 (obj -> matrix .)
    INT             reduce using rule 79 (obj -> matrix .)
    FLOAT           reduce using rule 79 (obj -> matrix .)
    RAT             reduce using rule 79 (obj -> matrix .)
    COMPX           reduce using rule 79 (obj -> matrix .)
    COLON           reduce using rule 79 (obj -> matrix .)
    DO              reduce using rule 79 (obj -> matrix .)
    WHEN            reduce using rule 79 (obj -> matrix .)
    RBRAKET         reduce using rule 79 (obj -> matrix .)
    THEN            reduce using rule 79 (obj -> matrix .)
    RBRACE          reduce using rule 79 (obj -> matrix .)


state 29

    (80) obj -> hash .

    EQCOMP          reduce using rule 80 (obj -> hash .)
    LESSTH          reduce using rule 80 (obj -> hash .)
    LESSEQTH        reduce using rule 80 (obj -> hash .)
    GREATH          reduce using rule 80 (obj -> hash .)
    GREATEQTH       reduce using rule 80 (obj -> hash .)
    NOTEQ           reduce using rule 80 (obj -> hash .)
    $end            reduce using rule 80 (obj -> hash .)
    END             reduce using rule 80 (obj -> hash .)
    RETURN          reduce using rule 80 (obj -> hash .)
    ELSE            reduce using rule 80 (obj -> hash .)
    ELSIF           reduce using rule 80 (obj -> hash .)
    COMMA           reduce using rule 80 (obj -> hash .)
    RPAREN          reduce using rule 80 (obj -> hash .)
    ID              reduce using rule 80 (obj -> hash .)
    DEF             reduce using rule 80 (obj -> hash .)
    IF              reduce using rule 80 (obj -> hash .)
    UNLESS          reduce using rule 80 (obj -> hash .)
    CASE            reduce using rule 80 (obj -> hash .)
    WHILE           reduce using rule 80 (obj -> hash .)
    INT             reduce using rule 80 (obj -> hash .)
    FLOAT           reduce using rule 80 (obj -> hash .)
    RAT             reduce using rule 80 (obj -> hash .)
    COMPX           reduce using rule 80 (obj -> hash .)
    COLON           reduce using rule 80 (obj -> hash .)
    DO              reduce using rule 80 (obj -> hash .)
    WHEN            reduce using rule 80 (obj -> hash .)
    RBRAKET         reduce using rule 80 (obj -> hash .)
    THEN            reduce using rule 80 (obj -> hash .)
    RBRACE          reduce using rule 80 (obj -> hash .)


state 30

    (81) obj -> strucSet .

    EQCOMP          reduce using rule 81 (obj -> strucSet .)
    LESSTH          reduce using rule 81 (obj -> strucSet .)
    LESSEQTH        reduce using rule 81 (obj -> strucSet .)
    GREATH          reduce using rule 81 (obj -> strucSet .)
    GREATEQTH       reduce using rule 81 (obj -> strucSet .)
    NOTEQ           reduce using rule 81 (obj -> strucSet .)
    $end            reduce using rule 81 (obj -> strucSet .)
    END             reduce using rule 81 (obj -> strucSet .)
    RETURN          reduce using rule 81 (obj -> strucSet .)
    ELSE            reduce using rule 81 (obj -> strucSet .)
    ELSIF           reduce using rule 81 (obj -> strucSet .)
    COMMA           reduce using rule 81 (obj -> strucSet .)
    RPAREN          reduce using rule 81 (obj -> strucSet .)
    ID              reduce using rule 81 (obj -> strucSet .)
    DEF             reduce using rule 81 (obj -> strucSet .)
    IF              reduce using rule 81 (obj -> strucSet .)
    UNLESS          reduce using rule 81 (obj -> strucSet .)
    CASE            reduce using rule 81 (obj -> strucSet .)
    WHILE           reduce using rule 81 (obj -> strucSet .)
    INT             reduce using rule 81 (obj -> strucSet .)
    FLOAT           reduce using rule 81 (obj -> strucSet .)
    RAT             reduce using rule 81 (obj -> strucSet .)
    COMPX           reduce using rule 81 (obj -> strucSet .)
    COLON           reduce using rule 81 (obj -> strucSet .)
    DO              reduce using rule 81 (obj -> strucSet .)
    WHEN            reduce using rule 81 (obj -> strucSet .)
    RBRAKET         reduce using rule 81 (obj -> strucSet .)
    THEN            reduce using rule 81 (obj -> strucSet .)
    RBRACE          reduce using rule 81 (obj -> strucSet .)


state 31

    (4) num -> INT .
    (83) range -> INT . DOT DOT INT

    EQCOMP          reduce using rule 4 (num -> INT .)
    LESSTH          reduce using rule 4 (num -> INT .)
    LESSEQTH        reduce using rule 4 (num -> INT .)
    GREATH          reduce using rule 4 (num -> INT .)
    GREATEQTH       reduce using rule 4 (num -> INT .)
    NOTEQ           reduce using rule 4 (num -> INT .)
    $end            reduce using rule 4 (num -> INT .)
    END             reduce using rule 4 (num -> INT .)
    RETURN          reduce using rule 4 (num -> INT .)
    ELSE            reduce using rule 4 (num -> INT .)
    ELSIF           reduce using rule 4 (num -> INT .)
    ROCKET          reduce using rule 4 (num -> INT .)
    COMMA           reduce using rule 4 (num -> INT .)
    RPAREN          reduce using rule 4 (num -> INT .)
    ID              reduce using rule 4 (num -> INT .)
    DEF             reduce using rule 4 (num -> INT .)
    IF              reduce using rule 4 (num -> INT .)
    UNLESS          reduce using rule 4 (num -> INT .)
    CASE            reduce using rule 4 (num -> INT .)
    WHILE           reduce using rule 4 (num -> INT .)
    INT             reduce using rule 4 (num -> INT .)
    FLOAT           reduce using rule 4 (num -> INT .)
    RAT             reduce using rule 4 (num -> INT .)
    COMPX           reduce using rule 4 (num -> INT .)
    COLON           reduce using rule 4 (num -> INT .)
    DO              reduce using rule 4 (num -> INT .)
    WHEN            reduce using rule 4 (num -> INT .)
    RBRAKET         reduce using rule 4 (num -> INT .)
    THEN            reduce using rule 4 (num -> INT .)
    RBRACE          reduce using rule 4 (num -> INT .)
    DOT             shift and go to state 64


state 32

    (82) range -> LPAREN . INT DOT DOT INT RPAREN
    (84) range -> LPAREN . STRING DOT DOT STRING

    INT             shift and go to state 65
    STRING          shift and go to state 66


state 33

    (90) matrix -> LBRAKET . rows RBRAKET
    (91) rows -> . row
    (92) rows -> . row COMMA rows
    (93) row -> . array
    (54) array -> . LBRAKET objs RBRAKET
    (55) array -> . LBRAKET ids RBRAKET
    (56) array -> . LBRAKET objs COMMA ids RBRAKET
    (57) array -> . LBRAKET ids COMMA objs RBRAKET

    LBRAKET         shift and go to state 67

    rows                           shift and go to state 68
    row                            shift and go to state 69
    array                          shift and go to state 70

state 34

    (70) hash -> LBRACE . elementsHash RBRACE
    (68) elementsHash -> . elementHash COMMA elementHash
    (69) elementsHash -> . elementHash COMMA elementsHash
    (67) elementHash -> . claveHash ROCKET obj
    (62) claveHash -> . STRING
    (63) claveHash -> . num
    (64) claveHash -> . bool
    (65) claveHash -> . range
    (66) claveHash -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 74
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33

    elementsHash                   shift and go to state 71
    elementHash                    shift and go to state 72
    claveHash                      shift and go to state 73
    num                            shift and go to state 75
    bool                           shift and go to state 76
    range                          shift and go to state 77
    matrix                         shift and go to state 78

state 35

    (58) strucSet -> SET . DOT NEW
    (59) strucSet -> SET . DOT NEW LPAREN RPAREN
    (60) strucSet -> SET . DOT NEW LPAREN array RPAREN
    (61) strucSet -> SET . array
    (54) array -> . LBRAKET objs RBRAKET
    (55) array -> . LBRAKET ids RBRAKET
    (56) array -> . LBRAKET objs COMMA ids RBRAKET
    (57) array -> . LBRAKET ids COMMA objs RBRAKET

    DOT             shift and go to state 79
    LBRAKET         shift and go to state 67

    array                          shift and go to state 80

state 36

    (41) control -> UNLESS comptn . COLON cmmd END
    (43) control -> UNLESS comptn . cmmd elses END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    COLON           shift and go to state 81
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 82
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 37

    (42) control -> UNLESS bool . COLON cmmd END
    (44) control -> UNLESS bool . cmmd elses END
    (77) obj -> bool .
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    COLON           shift and go to state 83
    EQCOMP          reduce using rule 77 (obj -> bool .)
    LESSTH          reduce using rule 77 (obj -> bool .)
    LESSEQTH        reduce using rule 77 (obj -> bool .)
    GREATH          reduce using rule 77 (obj -> bool .)
    GREATEQTH       reduce using rule 77 (obj -> bool .)
    NOTEQ           reduce using rule 77 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 84
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 38

    (50) control -> CASE ID . whens else END
    (51) control -> CASE ID . whens END
    (48) whens -> . when
    (49) whens -> . when whens
    (45) when -> . WHEN objs
    (46) when -> . WHEN objs THEN
    (47) when -> . WHEN comptn

    WHEN            shift and go to state 87

    whens                          shift and go to state 85
    when                           shift and go to state 86

state 39

    (71) control -> WHILE comptn . DO cmmd END

    DO              shift and go to state 88


state 40

    (72) control -> WHILE bool . DO cmmd END
    (77) obj -> bool .

    DO              shift and go to state 89
    EQCOMP          reduce using rule 77 (obj -> bool .)
    LESSTH          reduce using rule 77 (obj -> bool .)
    LESSEQTH        reduce using rule 77 (obj -> bool .)
    GREATH          reduce using rule 77 (obj -> bool .)
    GREATEQTH       reduce using rule 77 (obj -> bool .)
    NOTEQ           reduce using rule 77 (obj -> bool .)


state 41

    (14) optn -> num optr . num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    num                            shift and go to state 90

state 42

    (8) optr -> PLUS .

    INT             reduce using rule 8 (optr -> PLUS .)
    FLOAT           reduce using rule 8 (optr -> PLUS .)
    RAT             reduce using rule 8 (optr -> PLUS .)
    COMPX           reduce using rule 8 (optr -> PLUS .)


state 43

    (9) optr -> MINUS .

    INT             reduce using rule 9 (optr -> MINUS .)
    FLOAT           reduce using rule 9 (optr -> MINUS .)
    RAT             reduce using rule 9 (optr -> MINUS .)
    COMPX           reduce using rule 9 (optr -> MINUS .)


state 44

    (10) optr -> TIMES .

    INT             reduce using rule 10 (optr -> TIMES .)
    FLOAT           reduce using rule 10 (optr -> TIMES .)
    RAT             reduce using rule 10 (optr -> TIMES .)
    COMPX           reduce using rule 10 (optr -> TIMES .)


state 45

    (11) optr -> DIVIDE .

    INT             reduce using rule 11 (optr -> DIVIDE .)
    FLOAT           reduce using rule 11 (optr -> DIVIDE .)
    RAT             reduce using rule 11 (optr -> DIVIDE .)
    COMPX           reduce using rule 11 (optr -> DIVIDE .)


state 46

    (12) optr -> MODULE .

    INT             reduce using rule 12 (optr -> MODULE .)
    FLOAT           reduce using rule 12 (optr -> MODULE .)
    RAT             reduce using rule 12 (optr -> MODULE .)
    COMPX           reduce using rule 12 (optr -> MODULE .)


state 47

    (13) optr -> EXPON .

    INT             reduce using rule 13 (optr -> EXPON .)
    FLOAT           reduce using rule 13 (optr -> EXPON .)
    RAT             reduce using rule 13 (optr -> EXPON .)
    COMPX           reduce using rule 13 (optr -> EXPON .)


state 48

    (23) var -> ID EQUALS ID .

    $end            reduce using rule 23 (var -> ID EQUALS ID .)
    END             reduce using rule 23 (var -> ID EQUALS ID .)
    RETURN          reduce using rule 23 (var -> ID EQUALS ID .)
    ELSE            reduce using rule 23 (var -> ID EQUALS ID .)
    ELSIF           reduce using rule 23 (var -> ID EQUALS ID .)


state 49

    (22) var -> ID EQUALS obj .

    $end            reduce using rule 22 (var -> ID EQUALS obj .)
    END             reduce using rule 22 (var -> ID EQUALS obj .)
    RETURN          reduce using rule 22 (var -> ID EQUALS obj .)
    ELSE            reduce using rule 22 (var -> ID EQUALS obj .)
    ELSIF           reduce using rule 22 (var -> ID EQUALS obj .)


state 50

    (24) var -> ID EQUALS NIL .

    $end            reduce using rule 24 (var -> ID EQUALS NIL .)
    END             reduce using rule 24 (var -> ID EQUALS NIL .)
    RETURN          reduce using rule 24 (var -> ID EQUALS NIL .)
    ELSE            reduce using rule 24 (var -> ID EQUALS NIL .)
    ELSIF           reduce using rule 24 (var -> ID EQUALS NIL .)


state 51

    (77) obj -> bool .

    $end            reduce using rule 77 (obj -> bool .)
    END             reduce using rule 77 (obj -> bool .)
    RETURN          reduce using rule 77 (obj -> bool .)
    ELSE            reduce using rule 77 (obj -> bool .)
    ELSIF           reduce using rule 77 (obj -> bool .)
    COMMA           reduce using rule 77 (obj -> bool .)
    RPAREN          reduce using rule 77 (obj -> bool .)
    ID              reduce using rule 77 (obj -> bool .)
    DEF             reduce using rule 77 (obj -> bool .)
    IF              reduce using rule 77 (obj -> bool .)
    UNLESS          reduce using rule 77 (obj -> bool .)
    CASE            reduce using rule 77 (obj -> bool .)
    WHILE           reduce using rule 77 (obj -> bool .)
    INT             reduce using rule 77 (obj -> bool .)
    FLOAT           reduce using rule 77 (obj -> bool .)
    RAT             reduce using rule 77 (obj -> bool .)
    COMPX           reduce using rule 77 (obj -> bool .)
    COLON           reduce using rule 77 (obj -> bool .)
    DO              reduce using rule 77 (obj -> bool .)
    WHEN            reduce using rule 77 (obj -> bool .)
    RBRAKET         reduce using rule 77 (obj -> bool .)
    EQCOMP          reduce using rule 77 (obj -> bool .)
    LESSTH          reduce using rule 77 (obj -> bool .)
    LESSEQTH        reduce using rule 77 (obj -> bool .)
    GREATH          reduce using rule 77 (obj -> bool .)
    GREATEQTH       reduce using rule 77 (obj -> bool .)
    NOTEQ           reduce using rule 77 (obj -> bool .)
    THEN            reduce using rule 77 (obj -> bool .)
    RBRACE          reduce using rule 77 (obj -> bool .)


state 52

    (25) func -> DEF ID LPAREN . objs RPAREN cmmd END
    (26) func -> DEF ID LPAREN . RPAREN cmmd END
    (28) func -> DEF ID LPAREN . objs RPAREN cmmd RETURN obj END
    (29) func -> DEF ID LPAREN . RPAREN cmmd RETURN obj END
    (73) objs -> . obj
    (74) objs -> . obj COMMA objs
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    RPAREN          shift and go to state 92
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    objs                           shift and go to state 91
    obj                            shift and go to state 93
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 53

    (27) func -> DEF ID cmmd . END
    (30) func -> DEF ID cmmd . RETURN obj END

    END             shift and go to state 94
    RETURN          shift and go to state 95


state 54

    (37) control -> IF comptn cmmd . END
    (39) control -> IF comptn cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    END             shift and go to state 96
    ELSE            shift and go to state 100
    ELSIF           shift and go to state 101

    elses                          shift and go to state 97
    else                           shift and go to state 98
    elsif                          shift and go to state 99

state 55

    (38) control -> IF bool cmmd . END
    (40) control -> IF bool cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    END             shift and go to state 102
    ELSE            shift and go to state 100
    ELSIF           shift and go to state 101

    elses                          shift and go to state 103
    else                           shift and go to state 98
    elsif                          shift and go to state 99

state 56

    (15) comptn -> obj comptr . obj
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 104
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 57

    (16) comptr -> EQCOMP .

    STRING          reduce using rule 16 (comptr -> EQCOMP .)
    INT             reduce using rule 16 (comptr -> EQCOMP .)
    FLOAT           reduce using rule 16 (comptr -> EQCOMP .)
    RAT             reduce using rule 16 (comptr -> EQCOMP .)
    COMPX           reduce using rule 16 (comptr -> EQCOMP .)
    TRUE            reduce using rule 16 (comptr -> EQCOMP .)
    FALSE           reduce using rule 16 (comptr -> EQCOMP .)
    LPAREN          reduce using rule 16 (comptr -> EQCOMP .)
    LBRAKET         reduce using rule 16 (comptr -> EQCOMP .)
    LBRACE          reduce using rule 16 (comptr -> EQCOMP .)
    SET             reduce using rule 16 (comptr -> EQCOMP .)


state 58

    (17) comptr -> LESSTH .

    STRING          reduce using rule 17 (comptr -> LESSTH .)
    INT             reduce using rule 17 (comptr -> LESSTH .)
    FLOAT           reduce using rule 17 (comptr -> LESSTH .)
    RAT             reduce using rule 17 (comptr -> LESSTH .)
    COMPX           reduce using rule 17 (comptr -> LESSTH .)
    TRUE            reduce using rule 17 (comptr -> LESSTH .)
    FALSE           reduce using rule 17 (comptr -> LESSTH .)
    LPAREN          reduce using rule 17 (comptr -> LESSTH .)
    LBRAKET         reduce using rule 17 (comptr -> LESSTH .)
    LBRACE          reduce using rule 17 (comptr -> LESSTH .)
    SET             reduce using rule 17 (comptr -> LESSTH .)


state 59

    (18) comptr -> LESSEQTH .

    STRING          reduce using rule 18 (comptr -> LESSEQTH .)
    INT             reduce using rule 18 (comptr -> LESSEQTH .)
    FLOAT           reduce using rule 18 (comptr -> LESSEQTH .)
    RAT             reduce using rule 18 (comptr -> LESSEQTH .)
    COMPX           reduce using rule 18 (comptr -> LESSEQTH .)
    TRUE            reduce using rule 18 (comptr -> LESSEQTH .)
    FALSE           reduce using rule 18 (comptr -> LESSEQTH .)
    LPAREN          reduce using rule 18 (comptr -> LESSEQTH .)
    LBRAKET         reduce using rule 18 (comptr -> LESSEQTH .)
    LBRACE          reduce using rule 18 (comptr -> LESSEQTH .)
    SET             reduce using rule 18 (comptr -> LESSEQTH .)


state 60

    (19) comptr -> GREATH .

    STRING          reduce using rule 19 (comptr -> GREATH .)
    INT             reduce using rule 19 (comptr -> GREATH .)
    FLOAT           reduce using rule 19 (comptr -> GREATH .)
    RAT             reduce using rule 19 (comptr -> GREATH .)
    COMPX           reduce using rule 19 (comptr -> GREATH .)
    TRUE            reduce using rule 19 (comptr -> GREATH .)
    FALSE           reduce using rule 19 (comptr -> GREATH .)
    LPAREN          reduce using rule 19 (comptr -> GREATH .)
    LBRAKET         reduce using rule 19 (comptr -> GREATH .)
    LBRACE          reduce using rule 19 (comptr -> GREATH .)
    SET             reduce using rule 19 (comptr -> GREATH .)


state 61

    (20) comptr -> GREATEQTH .

    STRING          reduce using rule 20 (comptr -> GREATEQTH .)
    INT             reduce using rule 20 (comptr -> GREATEQTH .)
    FLOAT           reduce using rule 20 (comptr -> GREATEQTH .)
    RAT             reduce using rule 20 (comptr -> GREATEQTH .)
    COMPX           reduce using rule 20 (comptr -> GREATEQTH .)
    TRUE            reduce using rule 20 (comptr -> GREATEQTH .)
    FALSE           reduce using rule 20 (comptr -> GREATEQTH .)
    LPAREN          reduce using rule 20 (comptr -> GREATEQTH .)
    LBRAKET         reduce using rule 20 (comptr -> GREATEQTH .)
    LBRACE          reduce using rule 20 (comptr -> GREATEQTH .)
    SET             reduce using rule 20 (comptr -> GREATEQTH .)


state 62

    (21) comptr -> NOTEQ .

    STRING          reduce using rule 21 (comptr -> NOTEQ .)
    INT             reduce using rule 21 (comptr -> NOTEQ .)
    FLOAT           reduce using rule 21 (comptr -> NOTEQ .)
    RAT             reduce using rule 21 (comptr -> NOTEQ .)
    COMPX           reduce using rule 21 (comptr -> NOTEQ .)
    TRUE            reduce using rule 21 (comptr -> NOTEQ .)
    FALSE           reduce using rule 21 (comptr -> NOTEQ .)
    LPAREN          reduce using rule 21 (comptr -> NOTEQ .)
    LBRAKET         reduce using rule 21 (comptr -> NOTEQ .)
    LBRACE          reduce using rule 21 (comptr -> NOTEQ .)
    SET             reduce using rule 21 (comptr -> NOTEQ .)


state 63

    (85) range -> STRING DOT . DOT STRING

    DOT             shift and go to state 105


state 64

    (83) range -> INT DOT . DOT INT

    DOT             shift and go to state 106


state 65

    (82) range -> LPAREN INT . DOT DOT INT RPAREN

    DOT             shift and go to state 107


state 66

    (84) range -> LPAREN STRING . DOT DOT STRING

    DOT             shift and go to state 108


state 67

    (54) array -> LBRAKET . objs RBRAKET
    (55) array -> LBRAKET . ids RBRAKET
    (56) array -> LBRAKET . objs COMMA ids RBRAKET
    (57) array -> LBRAKET . ids COMMA objs RBRAKET
    (73) objs -> . obj
    (74) objs -> . obj COMMA objs
    (52) ids -> . ID
    (53) ids -> . ID COMMA ids
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    ID              shift and go to state 111
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    objs                           shift and go to state 109
    ids                            shift and go to state 110
    obj                            shift and go to state 93
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 68

    (90) matrix -> LBRAKET rows . RBRAKET

    RBRAKET         shift and go to state 112


state 69

    (91) rows -> row .
    (92) rows -> row . COMMA rows

    RBRAKET         reduce using rule 91 (rows -> row .)
    COMMA           shift and go to state 113


state 70

    (93) row -> array .

    COMMA           reduce using rule 93 (row -> array .)
    RBRAKET         reduce using rule 93 (row -> array .)


state 71

    (70) hash -> LBRACE elementsHash . RBRACE

    RBRACE          shift and go to state 114


state 72

    (68) elementsHash -> elementHash . COMMA elementHash
    (69) elementsHash -> elementHash . COMMA elementsHash

    COMMA           shift and go to state 115


state 73

    (67) elementHash -> claveHash . ROCKET obj

    ROCKET          shift and go to state 116


state 74

    (62) claveHash -> STRING .
    (85) range -> STRING . DOT DOT STRING

    ROCKET          reduce using rule 62 (claveHash -> STRING .)
    DOT             shift and go to state 63


state 75

    (63) claveHash -> num .

    ROCKET          reduce using rule 63 (claveHash -> num .)


state 76

    (64) claveHash -> bool .

    ROCKET          reduce using rule 64 (claveHash -> bool .)


state 77

    (65) claveHash -> range .

    ROCKET          reduce using rule 65 (claveHash -> range .)


state 78

    (66) claveHash -> matrix .

    ROCKET          reduce using rule 66 (claveHash -> matrix .)


state 79

    (58) strucSet -> SET DOT . NEW
    (59) strucSet -> SET DOT . NEW LPAREN RPAREN
    (60) strucSet -> SET DOT . NEW LPAREN array RPAREN

    NEW             shift and go to state 117


state 80

    (61) strucSet -> SET array .

    EQCOMP          reduce using rule 61 (strucSet -> SET array .)
    LESSTH          reduce using rule 61 (strucSet -> SET array .)
    LESSEQTH        reduce using rule 61 (strucSet -> SET array .)
    GREATH          reduce using rule 61 (strucSet -> SET array .)
    GREATEQTH       reduce using rule 61 (strucSet -> SET array .)
    NOTEQ           reduce using rule 61 (strucSet -> SET array .)
    $end            reduce using rule 61 (strucSet -> SET array .)
    END             reduce using rule 61 (strucSet -> SET array .)
    RETURN          reduce using rule 61 (strucSet -> SET array .)
    ELSE            reduce using rule 61 (strucSet -> SET array .)
    ELSIF           reduce using rule 61 (strucSet -> SET array .)
    COMMA           reduce using rule 61 (strucSet -> SET array .)
    RPAREN          reduce using rule 61 (strucSet -> SET array .)
    ID              reduce using rule 61 (strucSet -> SET array .)
    DEF             reduce using rule 61 (strucSet -> SET array .)
    IF              reduce using rule 61 (strucSet -> SET array .)
    UNLESS          reduce using rule 61 (strucSet -> SET array .)
    CASE            reduce using rule 61 (strucSet -> SET array .)
    WHILE           reduce using rule 61 (strucSet -> SET array .)
    INT             reduce using rule 61 (strucSet -> SET array .)
    FLOAT           reduce using rule 61 (strucSet -> SET array .)
    RAT             reduce using rule 61 (strucSet -> SET array .)
    COMPX           reduce using rule 61 (strucSet -> SET array .)
    COLON           reduce using rule 61 (strucSet -> SET array .)
    DO              reduce using rule 61 (strucSet -> SET array .)
    WHEN            reduce using rule 61 (strucSet -> SET array .)
    RBRAKET         reduce using rule 61 (strucSet -> SET array .)
    THEN            reduce using rule 61 (strucSet -> SET array .)
    RBRACE          reduce using rule 61 (strucSet -> SET array .)


state 81

    (41) control -> UNLESS comptn COLON . cmmd END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 118
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 82

    (43) control -> UNLESS comptn cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 100
    ELSIF           shift and go to state 101

    elses                          shift and go to state 119
    else                           shift and go to state 98
    elsif                          shift and go to state 99

state 83

    (42) control -> UNLESS bool COLON . cmmd END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 120
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 84

    (44) control -> UNLESS bool cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 100
    ELSIF           shift and go to state 101

    elses                          shift and go to state 121
    else                           shift and go to state 98
    elsif                          shift and go to state 99

state 85

    (50) control -> CASE ID whens . else END
    (51) control -> CASE ID whens . END
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd

    END             shift and go to state 123
    ELSE            shift and go to state 100

    else                           shift and go to state 122

state 86

    (48) whens -> when .
    (49) whens -> when . whens
    (48) whens -> . when
    (49) whens -> . when whens
    (45) when -> . WHEN objs
    (46) when -> . WHEN objs THEN
    (47) when -> . WHEN comptn

    END             reduce using rule 48 (whens -> when .)
    ELSE            reduce using rule 48 (whens -> when .)
    WHEN            shift and go to state 87

    when                           shift and go to state 86
    whens                          shift and go to state 124

state 87

    (45) when -> WHEN . objs
    (46) when -> WHEN . objs THEN
    (47) when -> WHEN . comptn
    (73) objs -> . obj
    (74) objs -> . obj COMMA objs
    (15) comptn -> . obj comptr obj
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    objs                           shift and go to state 125
    comptn                         shift and go to state 126
    obj                            shift and go to state 127
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 88

    (71) control -> WHILE comptn DO . cmmd END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 128
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 89

    (72) control -> WHILE bool DO . cmmd END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 129
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 90

    (14) optn -> num optr num .

    $end            reduce using rule 14 (optn -> num optr num .)
    END             reduce using rule 14 (optn -> num optr num .)
    RETURN          reduce using rule 14 (optn -> num optr num .)
    ELSE            reduce using rule 14 (optn -> num optr num .)
    ELSIF           reduce using rule 14 (optn -> num optr num .)


state 91

    (25) func -> DEF ID LPAREN objs . RPAREN cmmd END
    (28) func -> DEF ID LPAREN objs . RPAREN cmmd RETURN obj END

    RPAREN          shift and go to state 130


state 92

    (26) func -> DEF ID LPAREN RPAREN . cmmd END
    (29) func -> DEF ID LPAREN RPAREN . cmmd RETURN obj END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 131
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 93

    (73) objs -> obj .
    (74) objs -> obj . COMMA objs

  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 73 (objs -> obj .)
    RBRAKET         reduce using rule 73 (objs -> obj .)
    THEN            reduce using rule 73 (objs -> obj .)
    WHEN            reduce using rule 73 (objs -> obj .)
    END             reduce using rule 73 (objs -> obj .)
    ELSE            reduce using rule 73 (objs -> obj .)
    COMMA           shift and go to state 132

  ! COMMA           [ reduce using rule 73 (objs -> obj .) ]


state 94

    (27) func -> DEF ID cmmd END .

    $end            reduce using rule 27 (func -> DEF ID cmmd END .)
    END             reduce using rule 27 (func -> DEF ID cmmd END .)
    RETURN          reduce using rule 27 (func -> DEF ID cmmd END .)
    ELSE            reduce using rule 27 (func -> DEF ID cmmd END .)
    ELSIF           reduce using rule 27 (func -> DEF ID cmmd END .)


state 95

    (30) func -> DEF ID cmmd RETURN . obj END
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 133
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 96

    (37) control -> IF comptn cmmd END .

    $end            reduce using rule 37 (control -> IF comptn cmmd END .)
    END             reduce using rule 37 (control -> IF comptn cmmd END .)
    RETURN          reduce using rule 37 (control -> IF comptn cmmd END .)
    ELSE            reduce using rule 37 (control -> IF comptn cmmd END .)
    ELSIF           reduce using rule 37 (control -> IF comptn cmmd END .)


state 97

    (39) control -> IF comptn cmmd elses . END

    END             shift and go to state 134


state 98

    (35) elses -> else .

    END             reduce using rule 35 (elses -> else .)


state 99

    (36) elses -> elsif . elses
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 100
    ELSIF           shift and go to state 101

    elsif                          shift and go to state 99
    elses                          shift and go to state 135
    else                           shift and go to state 98

state 100

    (31) else -> ELSE . comptn cmmd
    (32) else -> ELSE . bool cmmd
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    comptn                         shift and go to state 136
    bool                           shift and go to state 137
    obj                            shift and go to state 22
    num                            shift and go to state 26
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 101

    (33) elsif -> ELSIF . comptn cmmd
    (34) elsif -> ELSIF . bool cmmd
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    comptn                         shift and go to state 138
    bool                           shift and go to state 139
    obj                            shift and go to state 22
    num                            shift and go to state 26
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 102

    (38) control -> IF bool cmmd END .

    $end            reduce using rule 38 (control -> IF bool cmmd END .)
    END             reduce using rule 38 (control -> IF bool cmmd END .)
    RETURN          reduce using rule 38 (control -> IF bool cmmd END .)
    ELSE            reduce using rule 38 (control -> IF bool cmmd END .)
    ELSIF           reduce using rule 38 (control -> IF bool cmmd END .)


state 103

    (40) control -> IF bool cmmd elses . END

    END             shift and go to state 140


state 104

    (15) comptn -> obj comptr obj .

    ID              reduce using rule 15 (comptn -> obj comptr obj .)
    DEF             reduce using rule 15 (comptn -> obj comptr obj .)
    IF              reduce using rule 15 (comptn -> obj comptr obj .)
    UNLESS          reduce using rule 15 (comptn -> obj comptr obj .)
    CASE            reduce using rule 15 (comptn -> obj comptr obj .)
    WHILE           reduce using rule 15 (comptn -> obj comptr obj .)
    INT             reduce using rule 15 (comptn -> obj comptr obj .)
    FLOAT           reduce using rule 15 (comptn -> obj comptr obj .)
    RAT             reduce using rule 15 (comptn -> obj comptr obj .)
    COMPX           reduce using rule 15 (comptn -> obj comptr obj .)
    COLON           reduce using rule 15 (comptn -> obj comptr obj .)
    DO              reduce using rule 15 (comptn -> obj comptr obj .)
    WHEN            reduce using rule 15 (comptn -> obj comptr obj .)
    END             reduce using rule 15 (comptn -> obj comptr obj .)
    ELSE            reduce using rule 15 (comptn -> obj comptr obj .)


state 105

    (85) range -> STRING DOT DOT . STRING

    STRING          shift and go to state 141


state 106

    (83) range -> INT DOT DOT . INT

    INT             shift and go to state 142


state 107

    (82) range -> LPAREN INT DOT . DOT INT RPAREN

    DOT             shift and go to state 143


state 108

    (84) range -> LPAREN STRING DOT . DOT STRING

    DOT             shift and go to state 144


state 109

    (54) array -> LBRAKET objs . RBRAKET
    (56) array -> LBRAKET objs . COMMA ids RBRAKET

    RBRAKET         shift and go to state 145
    COMMA           shift and go to state 146


state 110

    (55) array -> LBRAKET ids . RBRAKET
    (57) array -> LBRAKET ids . COMMA objs RBRAKET

    RBRAKET         shift and go to state 147
    COMMA           shift and go to state 148


state 111

    (52) ids -> ID .
    (53) ids -> ID . COMMA ids

  ! shift/reduce conflict for COMMA resolved as shift
    RBRAKET         reduce using rule 52 (ids -> ID .)
    COMMA           shift and go to state 149

  ! COMMA           [ reduce using rule 52 (ids -> ID .) ]


state 112

    (90) matrix -> LBRAKET rows RBRAKET .

    EQCOMP          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    LESSTH          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    LESSEQTH        reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    GREATH          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    GREATEQTH       reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    NOTEQ           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    $end            reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    END             reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    RETURN          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    ELSE            reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    ELSIF           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    ROCKET          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    COMMA           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    RPAREN          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    ID              reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    DEF             reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    IF              reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    UNLESS          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    CASE            reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    WHILE           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    INT             reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    FLOAT           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    RAT             reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    COMPX           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    COLON           reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    DO              reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    WHEN            reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    RBRAKET         reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    THEN            reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)
    RBRACE          reduce using rule 90 (matrix -> LBRAKET rows RBRAKET .)


state 113

    (92) rows -> row COMMA . rows
    (91) rows -> . row
    (92) rows -> . row COMMA rows
    (93) row -> . array
    (54) array -> . LBRAKET objs RBRAKET
    (55) array -> . LBRAKET ids RBRAKET
    (56) array -> . LBRAKET objs COMMA ids RBRAKET
    (57) array -> . LBRAKET ids COMMA objs RBRAKET

    LBRAKET         shift and go to state 67

    row                            shift and go to state 69
    rows                           shift and go to state 150
    array                          shift and go to state 70

state 114

    (70) hash -> LBRACE elementsHash RBRACE .

    EQCOMP          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    LESSTH          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    LESSEQTH        reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    GREATH          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    GREATEQTH       reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    NOTEQ           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    $end            reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    END             reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    RETURN          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    ELSE            reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    ELSIF           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    COMMA           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    RPAREN          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    ID              reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    DEF             reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    IF              reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    UNLESS          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    CASE            reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    WHILE           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    INT             reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    FLOAT           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    RAT             reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    COMPX           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    COLON           reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    DO              reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    WHEN            reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    RBRAKET         reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    THEN            reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)
    RBRACE          reduce using rule 70 (hash -> LBRACE elementsHash RBRACE .)


state 115

    (68) elementsHash -> elementHash COMMA . elementHash
    (69) elementsHash -> elementHash COMMA . elementsHash
    (67) elementHash -> . claveHash ROCKET obj
    (68) elementsHash -> . elementHash COMMA elementHash
    (69) elementsHash -> . elementHash COMMA elementsHash
    (62) claveHash -> . STRING
    (63) claveHash -> . num
    (64) claveHash -> . bool
    (65) claveHash -> . range
    (66) claveHash -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 74
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33

    elementHash                    shift and go to state 151
    elementsHash                   shift and go to state 152
    claveHash                      shift and go to state 73
    num                            shift and go to state 75
    bool                           shift and go to state 76
    range                          shift and go to state 77
    matrix                         shift and go to state 78

state 116

    (67) elementHash -> claveHash ROCKET . obj
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 153
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 117

    (58) strucSet -> SET DOT NEW .
    (59) strucSet -> SET DOT NEW . LPAREN RPAREN
    (60) strucSet -> SET DOT NEW . LPAREN array RPAREN

    EQCOMP          reduce using rule 58 (strucSet -> SET DOT NEW .)
    LESSTH          reduce using rule 58 (strucSet -> SET DOT NEW .)
    LESSEQTH        reduce using rule 58 (strucSet -> SET DOT NEW .)
    GREATH          reduce using rule 58 (strucSet -> SET DOT NEW .)
    GREATEQTH       reduce using rule 58 (strucSet -> SET DOT NEW .)
    NOTEQ           reduce using rule 58 (strucSet -> SET DOT NEW .)
    $end            reduce using rule 58 (strucSet -> SET DOT NEW .)
    END             reduce using rule 58 (strucSet -> SET DOT NEW .)
    RETURN          reduce using rule 58 (strucSet -> SET DOT NEW .)
    ELSE            reduce using rule 58 (strucSet -> SET DOT NEW .)
    ELSIF           reduce using rule 58 (strucSet -> SET DOT NEW .)
    COMMA           reduce using rule 58 (strucSet -> SET DOT NEW .)
    RPAREN          reduce using rule 58 (strucSet -> SET DOT NEW .)
    ID              reduce using rule 58 (strucSet -> SET DOT NEW .)
    DEF             reduce using rule 58 (strucSet -> SET DOT NEW .)
    IF              reduce using rule 58 (strucSet -> SET DOT NEW .)
    UNLESS          reduce using rule 58 (strucSet -> SET DOT NEW .)
    CASE            reduce using rule 58 (strucSet -> SET DOT NEW .)
    WHILE           reduce using rule 58 (strucSet -> SET DOT NEW .)
    INT             reduce using rule 58 (strucSet -> SET DOT NEW .)
    FLOAT           reduce using rule 58 (strucSet -> SET DOT NEW .)
    RAT             reduce using rule 58 (strucSet -> SET DOT NEW .)
    COMPX           reduce using rule 58 (strucSet -> SET DOT NEW .)
    COLON           reduce using rule 58 (strucSet -> SET DOT NEW .)
    DO              reduce using rule 58 (strucSet -> SET DOT NEW .)
    WHEN            reduce using rule 58 (strucSet -> SET DOT NEW .)
    RBRAKET         reduce using rule 58 (strucSet -> SET DOT NEW .)
    THEN            reduce using rule 58 (strucSet -> SET DOT NEW .)
    RBRACE          reduce using rule 58 (strucSet -> SET DOT NEW .)
    LPAREN          shift and go to state 154


state 118

    (41) control -> UNLESS comptn COLON cmmd . END

    END             shift and go to state 155


state 119

    (43) control -> UNLESS comptn cmmd elses . END

    END             shift and go to state 156


state 120

    (42) control -> UNLESS bool COLON cmmd . END

    END             shift and go to state 157


state 121

    (44) control -> UNLESS bool cmmd elses . END

    END             shift and go to state 158


state 122

    (50) control -> CASE ID whens else . END

    END             shift and go to state 159


state 123

    (51) control -> CASE ID whens END .

    $end            reduce using rule 51 (control -> CASE ID whens END .)
    END             reduce using rule 51 (control -> CASE ID whens END .)
    RETURN          reduce using rule 51 (control -> CASE ID whens END .)
    ELSE            reduce using rule 51 (control -> CASE ID whens END .)
    ELSIF           reduce using rule 51 (control -> CASE ID whens END .)


state 124

    (49) whens -> when whens .

    END             reduce using rule 49 (whens -> when whens .)
    ELSE            reduce using rule 49 (whens -> when whens .)


state 125

    (45) when -> WHEN objs .
    (46) when -> WHEN objs . THEN

    WHEN            reduce using rule 45 (when -> WHEN objs .)
    END             reduce using rule 45 (when -> WHEN objs .)
    ELSE            reduce using rule 45 (when -> WHEN objs .)
    THEN            shift and go to state 160


state 126

    (47) when -> WHEN comptn .

    WHEN            reduce using rule 47 (when -> WHEN comptn .)
    END             reduce using rule 47 (when -> WHEN comptn .)
    ELSE            reduce using rule 47 (when -> WHEN comptn .)


state 127

    (73) objs -> obj .
    (74) objs -> obj . COMMA objs
    (15) comptn -> obj . comptr obj
    (16) comptr -> . EQCOMP
    (17) comptr -> . LESSTH
    (18) comptr -> . LESSEQTH
    (19) comptr -> . GREATH
    (20) comptr -> . GREATEQTH
    (21) comptr -> . NOTEQ

    THEN            reduce using rule 73 (objs -> obj .)
    WHEN            reduce using rule 73 (objs -> obj .)
    END             reduce using rule 73 (objs -> obj .)
    ELSE            reduce using rule 73 (objs -> obj .)
    COMMA           shift and go to state 132
    EQCOMP          shift and go to state 57
    LESSTH          shift and go to state 58
    LESSEQTH        shift and go to state 59
    GREATH          shift and go to state 60
    GREATEQTH       shift and go to state 61
    NOTEQ           shift and go to state 62

    comptr                         shift and go to state 56

state 128

    (71) control -> WHILE comptn DO cmmd . END

    END             shift and go to state 161


state 129

    (72) control -> WHILE bool DO cmmd . END

    END             shift and go to state 162


state 130

    (25) func -> DEF ID LPAREN objs RPAREN . cmmd END
    (28) func -> DEF ID LPAREN objs RPAREN . cmmd RETURN obj END
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 163
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 131

    (26) func -> DEF ID LPAREN RPAREN cmmd . END
    (29) func -> DEF ID LPAREN RPAREN cmmd . RETURN obj END

    END             shift and go to state 164
    RETURN          shift and go to state 165


state 132

    (74) objs -> obj COMMA . objs
    (73) objs -> . obj
    (74) objs -> . obj COMMA objs
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 93
    objs                           shift and go to state 166
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 133

    (30) func -> DEF ID cmmd RETURN obj . END

    END             shift and go to state 167


state 134

    (39) control -> IF comptn cmmd elses END .

    $end            reduce using rule 39 (control -> IF comptn cmmd elses END .)
    END             reduce using rule 39 (control -> IF comptn cmmd elses END .)
    RETURN          reduce using rule 39 (control -> IF comptn cmmd elses END .)
    ELSE            reduce using rule 39 (control -> IF comptn cmmd elses END .)
    ELSIF           reduce using rule 39 (control -> IF comptn cmmd elses END .)


state 135

    (36) elses -> elsif elses .

    END             reduce using rule 36 (elses -> elsif elses .)


state 136

    (31) else -> ELSE comptn . cmmd
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 168
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 137

    (32) else -> ELSE bool . cmmd
    (77) obj -> bool .
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 77 (obj -> bool .)
    LESSTH          reduce using rule 77 (obj -> bool .)
    LESSEQTH        reduce using rule 77 (obj -> bool .)
    GREATH          reduce using rule 77 (obj -> bool .)
    GREATEQTH       reduce using rule 77 (obj -> bool .)
    NOTEQ           reduce using rule 77 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 169
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 138

    (33) elsif -> ELSIF comptn . cmmd
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 170
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 139

    (34) elsif -> ELSIF bool . cmmd
    (77) obj -> bool .
    (86) cmmd -> . var
    (87) cmmd -> . func
    (88) cmmd -> . control
    (89) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (71) control -> . WHILE comptn DO cmmd END
    (72) control -> . WHILE bool DO cmmd END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 77 (obj -> bool .)
    LESSTH          reduce using rule 77 (obj -> bool .)
    LESSEQTH        reduce using rule 77 (obj -> bool .)
    GREATH          reduce using rule 77 (obj -> bool .)
    GREATEQTH       reduce using rule 77 (obj -> bool .)
    NOTEQ           reduce using rule 77 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    WHILE           shift and go to state 12
    INT             shift and go to state 14
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17

    cmmd                           shift and go to state 171
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 13

state 140

    (40) control -> IF bool cmmd elses END .

    $end            reduce using rule 40 (control -> IF bool cmmd elses END .)
    END             reduce using rule 40 (control -> IF bool cmmd elses END .)
    RETURN          reduce using rule 40 (control -> IF bool cmmd elses END .)
    ELSE            reduce using rule 40 (control -> IF bool cmmd elses END .)
    ELSIF           reduce using rule 40 (control -> IF bool cmmd elses END .)


state 141

    (85) range -> STRING DOT DOT STRING .

    EQCOMP          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    LESSTH          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    LESSEQTH        reduce using rule 85 (range -> STRING DOT DOT STRING .)
    GREATH          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    GREATEQTH       reduce using rule 85 (range -> STRING DOT DOT STRING .)
    NOTEQ           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    $end            reduce using rule 85 (range -> STRING DOT DOT STRING .)
    END             reduce using rule 85 (range -> STRING DOT DOT STRING .)
    RETURN          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    ELSE            reduce using rule 85 (range -> STRING DOT DOT STRING .)
    ELSIF           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    ROCKET          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    COMMA           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    RPAREN          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    ID              reduce using rule 85 (range -> STRING DOT DOT STRING .)
    DEF             reduce using rule 85 (range -> STRING DOT DOT STRING .)
    IF              reduce using rule 85 (range -> STRING DOT DOT STRING .)
    UNLESS          reduce using rule 85 (range -> STRING DOT DOT STRING .)
    CASE            reduce using rule 85 (range -> STRING DOT DOT STRING .)
    WHILE           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    INT             reduce using rule 85 (range -> STRING DOT DOT STRING .)
    FLOAT           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    RAT             reduce using rule 85 (range -> STRING DOT DOT STRING .)
    COMPX           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    COLON           reduce using rule 85 (range -> STRING DOT DOT STRING .)
    DO              reduce using rule 85 (range -> STRING DOT DOT STRING .)
    WHEN            reduce using rule 85 (range -> STRING DOT DOT STRING .)
    RBRAKET         reduce using rule 85 (range -> STRING DOT DOT STRING .)
    THEN            reduce using rule 85 (range -> STRING DOT DOT STRING .)
    RBRACE          reduce using rule 85 (range -> STRING DOT DOT STRING .)


state 142

    (83) range -> INT DOT DOT INT .

    EQCOMP          reduce using rule 83 (range -> INT DOT DOT INT .)
    LESSTH          reduce using rule 83 (range -> INT DOT DOT INT .)
    LESSEQTH        reduce using rule 83 (range -> INT DOT DOT INT .)
    GREATH          reduce using rule 83 (range -> INT DOT DOT INT .)
    GREATEQTH       reduce using rule 83 (range -> INT DOT DOT INT .)
    NOTEQ           reduce using rule 83 (range -> INT DOT DOT INT .)
    $end            reduce using rule 83 (range -> INT DOT DOT INT .)
    END             reduce using rule 83 (range -> INT DOT DOT INT .)
    RETURN          reduce using rule 83 (range -> INT DOT DOT INT .)
    ELSE            reduce using rule 83 (range -> INT DOT DOT INT .)
    ELSIF           reduce using rule 83 (range -> INT DOT DOT INT .)
    ROCKET          reduce using rule 83 (range -> INT DOT DOT INT .)
    COMMA           reduce using rule 83 (range -> INT DOT DOT INT .)
    RPAREN          reduce using rule 83 (range -> INT DOT DOT INT .)
    ID              reduce using rule 83 (range -> INT DOT DOT INT .)
    DEF             reduce using rule 83 (range -> INT DOT DOT INT .)
    IF              reduce using rule 83 (range -> INT DOT DOT INT .)
    UNLESS          reduce using rule 83 (range -> INT DOT DOT INT .)
    CASE            reduce using rule 83 (range -> INT DOT DOT INT .)
    WHILE           reduce using rule 83 (range -> INT DOT DOT INT .)
    INT             reduce using rule 83 (range -> INT DOT DOT INT .)
    FLOAT           reduce using rule 83 (range -> INT DOT DOT INT .)
    RAT             reduce using rule 83 (range -> INT DOT DOT INT .)
    COMPX           reduce using rule 83 (range -> INT DOT DOT INT .)
    COLON           reduce using rule 83 (range -> INT DOT DOT INT .)
    DO              reduce using rule 83 (range -> INT DOT DOT INT .)
    WHEN            reduce using rule 83 (range -> INT DOT DOT INT .)
    RBRAKET         reduce using rule 83 (range -> INT DOT DOT INT .)
    THEN            reduce using rule 83 (range -> INT DOT DOT INT .)
    RBRACE          reduce using rule 83 (range -> INT DOT DOT INT .)


state 143

    (82) range -> LPAREN INT DOT DOT . INT RPAREN

    INT             shift and go to state 172


state 144

    (84) range -> LPAREN STRING DOT DOT . STRING

    STRING          shift and go to state 173


state 145

    (54) array -> LBRAKET objs RBRAKET .

    COMMA           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    RBRAKET         reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    EQCOMP          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    LESSTH          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    LESSEQTH        reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    GREATH          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    GREATEQTH       reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    NOTEQ           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    $end            reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    END             reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    RETURN          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    ELSE            reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    ELSIF           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    RPAREN          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    ID              reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    DEF             reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    IF              reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    UNLESS          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    CASE            reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    WHILE           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    INT             reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    FLOAT           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    RAT             reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    COMPX           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    COLON           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    DO              reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    WHEN            reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    THEN            reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    RBRACE          reduce using rule 54 (array -> LBRAKET objs RBRAKET .)


state 146

    (56) array -> LBRAKET objs COMMA . ids RBRAKET
    (52) ids -> . ID
    (53) ids -> . ID COMMA ids

    ID              shift and go to state 111

    ids                            shift and go to state 174

state 147

    (55) array -> LBRAKET ids RBRAKET .

    COMMA           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    RBRAKET         reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    EQCOMP          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    LESSTH          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    LESSEQTH        reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    GREATH          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    GREATEQTH       reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    NOTEQ           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    $end            reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    END             reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    RETURN          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    ELSE            reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    ELSIF           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    RPAREN          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    ID              reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    DEF             reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    IF              reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    UNLESS          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    CASE            reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    WHILE           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    INT             reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    FLOAT           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    RAT             reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    COMPX           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    COLON           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    DO              reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    WHEN            reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    THEN            reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    RBRACE          reduce using rule 55 (array -> LBRAKET ids RBRAKET .)


state 148

    (57) array -> LBRAKET ids COMMA . objs RBRAKET
    (73) objs -> . obj
    (74) objs -> . obj COMMA objs
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    objs                           shift and go to state 175
    obj                            shift and go to state 93
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 149

    (53) ids -> ID COMMA . ids
    (52) ids -> . ID
    (53) ids -> . ID COMMA ids

    ID              shift and go to state 111

    ids                            shift and go to state 176

state 150

    (92) rows -> row COMMA rows .

    RBRAKET         reduce using rule 92 (rows -> row COMMA rows .)


state 151

    (68) elementsHash -> elementHash COMMA elementHash .
    (68) elementsHash -> elementHash . COMMA elementHash
    (69) elementsHash -> elementHash . COMMA elementsHash

    RBRACE          reduce using rule 68 (elementsHash -> elementHash COMMA elementHash .)
    COMMA           shift and go to state 115


state 152

    (69) elementsHash -> elementHash COMMA elementsHash .

    RBRACE          reduce using rule 69 (elementsHash -> elementHash COMMA elementsHash .)


state 153

    (67) elementHash -> claveHash ROCKET obj .

    COMMA           reduce using rule 67 (elementHash -> claveHash ROCKET obj .)
    RBRACE          reduce using rule 67 (elementHash -> claveHash ROCKET obj .)


state 154

    (59) strucSet -> SET DOT NEW LPAREN . RPAREN
    (60) strucSet -> SET DOT NEW LPAREN . array RPAREN
    (54) array -> . LBRAKET objs RBRAKET
    (55) array -> . LBRAKET ids RBRAKET
    (56) array -> . LBRAKET objs COMMA ids RBRAKET
    (57) array -> . LBRAKET ids COMMA objs RBRAKET

    RPAREN          shift and go to state 177
    LBRAKET         shift and go to state 67

    array                          shift and go to state 178

state 155

    (41) control -> UNLESS comptn COLON cmmd END .

    $end            reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    END             reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    RETURN          reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    ELSE            reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    ELSIF           reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)


state 156

    (43) control -> UNLESS comptn cmmd elses END .

    $end            reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    END             reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    RETURN          reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    ELSE            reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    ELSIF           reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)


state 157

    (42) control -> UNLESS bool COLON cmmd END .

    $end            reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    END             reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    RETURN          reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    ELSE            reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    ELSIF           reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)


state 158

    (44) control -> UNLESS bool cmmd elses END .

    $end            reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    END             reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    RETURN          reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    ELSE            reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    ELSIF           reduce using rule 44 (control -> UNLESS bool cmmd elses END .)


state 159

    (50) control -> CASE ID whens else END .

    $end            reduce using rule 50 (control -> CASE ID whens else END .)
    END             reduce using rule 50 (control -> CASE ID whens else END .)
    RETURN          reduce using rule 50 (control -> CASE ID whens else END .)
    ELSE            reduce using rule 50 (control -> CASE ID whens else END .)
    ELSIF           reduce using rule 50 (control -> CASE ID whens else END .)


state 160

    (46) when -> WHEN objs THEN .

    WHEN            reduce using rule 46 (when -> WHEN objs THEN .)
    END             reduce using rule 46 (when -> WHEN objs THEN .)
    ELSE            reduce using rule 46 (when -> WHEN objs THEN .)


state 161

    (71) control -> WHILE comptn DO cmmd END .

    $end            reduce using rule 71 (control -> WHILE comptn DO cmmd END .)
    END             reduce using rule 71 (control -> WHILE comptn DO cmmd END .)
    RETURN          reduce using rule 71 (control -> WHILE comptn DO cmmd END .)
    ELSE            reduce using rule 71 (control -> WHILE comptn DO cmmd END .)
    ELSIF           reduce using rule 71 (control -> WHILE comptn DO cmmd END .)


state 162

    (72) control -> WHILE bool DO cmmd END .

    $end            reduce using rule 72 (control -> WHILE bool DO cmmd END .)
    END             reduce using rule 72 (control -> WHILE bool DO cmmd END .)
    RETURN          reduce using rule 72 (control -> WHILE bool DO cmmd END .)
    ELSE            reduce using rule 72 (control -> WHILE bool DO cmmd END .)
    ELSIF           reduce using rule 72 (control -> WHILE bool DO cmmd END .)


state 163

    (25) func -> DEF ID LPAREN objs RPAREN cmmd . END
    (28) func -> DEF ID LPAREN objs RPAREN cmmd . RETURN obj END

    END             shift and go to state 179
    RETURN          shift and go to state 180


state 164

    (26) func -> DEF ID LPAREN RPAREN cmmd END .

    $end            reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    END             reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    RETURN          reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    ELSE            reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    ELSIF           reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)


state 165

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN . obj END
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 181
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 166

    (74) objs -> obj COMMA objs .

    RPAREN          reduce using rule 74 (objs -> obj COMMA objs .)
    RBRAKET         reduce using rule 74 (objs -> obj COMMA objs .)
    COMMA           reduce using rule 74 (objs -> obj COMMA objs .)
    THEN            reduce using rule 74 (objs -> obj COMMA objs .)
    WHEN            reduce using rule 74 (objs -> obj COMMA objs .)
    END             reduce using rule 74 (objs -> obj COMMA objs .)
    ELSE            reduce using rule 74 (objs -> obj COMMA objs .)


state 167

    (30) func -> DEF ID cmmd RETURN obj END .

    $end            reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    END             reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    RETURN          reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    ELSE            reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    ELSIF           reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)


state 168

    (31) else -> ELSE comptn cmmd .

    END             reduce using rule 31 (else -> ELSE comptn cmmd .)


state 169

    (32) else -> ELSE bool cmmd .

    END             reduce using rule 32 (else -> ELSE bool cmmd .)


state 170

    (33) elsif -> ELSIF comptn cmmd .

    ELSE            reduce using rule 33 (elsif -> ELSIF comptn cmmd .)
    ELSIF           reduce using rule 33 (elsif -> ELSIF comptn cmmd .)


state 171

    (34) elsif -> ELSIF bool cmmd .

    ELSE            reduce using rule 34 (elsif -> ELSIF bool cmmd .)
    ELSIF           reduce using rule 34 (elsif -> ELSIF bool cmmd .)


state 172

    (82) range -> LPAREN INT DOT DOT INT . RPAREN

    RPAREN          shift and go to state 182


state 173

    (84) range -> LPAREN STRING DOT DOT STRING .

    EQCOMP          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    LESSTH          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    LESSEQTH        reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    GREATH          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    GREATEQTH       reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    NOTEQ           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    $end            reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    END             reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    RETURN          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    ELSE            reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    ELSIF           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    ROCKET          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    COMMA           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    RPAREN          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    ID              reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    DEF             reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    IF              reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    UNLESS          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    CASE            reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    WHILE           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    INT             reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    FLOAT           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    RAT             reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    COMPX           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    COLON           reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    DO              reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    WHEN            reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    RBRAKET         reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    THEN            reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)
    RBRACE          reduce using rule 84 (range -> LPAREN STRING DOT DOT STRING .)


state 174

    (56) array -> LBRAKET objs COMMA ids . RBRAKET

    RBRAKET         shift and go to state 183


state 175

    (57) array -> LBRAKET ids COMMA objs . RBRAKET

    RBRAKET         shift and go to state 184


state 176

    (53) ids -> ID COMMA ids .

    RBRAKET         reduce using rule 53 (ids -> ID COMMA ids .)
    COMMA           reduce using rule 53 (ids -> ID COMMA ids .)


state 177

    (59) strucSet -> SET DOT NEW LPAREN RPAREN .

    EQCOMP          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    LESSTH          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    LESSEQTH        reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    GREATH          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    GREATEQTH       reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    NOTEQ           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    $end            reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    END             reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    RETURN          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    ELSE            reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    ELSIF           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    COMMA           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    RPAREN          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    ID              reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    DEF             reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    IF              reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    UNLESS          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    CASE            reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    WHILE           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    INT             reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    FLOAT           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    RAT             reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    COMPX           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    COLON           reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    DO              reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    WHEN            reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    RBRAKET         reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    THEN            reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)
    RBRACE          reduce using rule 59 (strucSet -> SET DOT NEW LPAREN RPAREN .)


state 178

    (60) strucSet -> SET DOT NEW LPAREN array . RPAREN

    RPAREN          shift and go to state 185


state 179

    (25) func -> DEF ID LPAREN objs RPAREN cmmd END .

    $end            reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    END             reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    RETURN          reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    ELSE            reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    ELSIF           reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)


state 180

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN . obj END
    (75) obj -> . STRING
    (76) obj -> . num
    (77) obj -> . bool
    (78) obj -> . range
    (79) obj -> . matrix
    (80) obj -> . hash
    (81) obj -> . strucSet
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (82) range -> . LPAREN INT DOT DOT INT RPAREN
    (83) range -> . INT DOT DOT INT
    (84) range -> . LPAREN STRING DOT DOT STRING
    (85) range -> . STRING DOT DOT STRING
    (90) matrix -> . LBRAKET rows RBRAKET
    (70) hash -> . LBRACE elementsHash RBRACE
    (58) strucSet -> . SET DOT NEW
    (59) strucSet -> . SET DOT NEW LPAREN RPAREN
    (60) strucSet -> . SET DOT NEW LPAREN array RPAREN
    (61) strucSet -> . SET array

    STRING          shift and go to state 25
    INT             shift and go to state 31
    FLOAT           shift and go to state 15
    RAT             shift and go to state 16
    COMPX           shift and go to state 17
    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    LPAREN          shift and go to state 32
    LBRAKET         shift and go to state 33
    LBRACE          shift and go to state 34
    SET             shift and go to state 35

    obj                            shift and go to state 186
    num                            shift and go to state 26
    bool                           shift and go to state 51
    range                          shift and go to state 27
    matrix                         shift and go to state 28
    hash                           shift and go to state 29
    strucSet                       shift and go to state 30

state 181

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN obj . END

    END             shift and go to state 187


state 182

    (82) range -> LPAREN INT DOT DOT INT RPAREN .

    EQCOMP          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    LESSTH          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    LESSEQTH        reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    GREATH          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    GREATEQTH       reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    NOTEQ           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    $end            reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    END             reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RETURN          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ELSE            reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ELSIF           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ROCKET          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COMMA           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RPAREN          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ID              reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    DEF             reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    IF              reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    UNLESS          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    CASE            reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    WHILE           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    INT             reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    FLOAT           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RAT             reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COMPX           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COLON           reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    DO              reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    WHEN            reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RBRAKET         reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    THEN            reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RBRACE          reduce using rule 82 (range -> LPAREN INT DOT DOT INT RPAREN .)


state 183

    (56) array -> LBRAKET objs COMMA ids RBRAKET .

    COMMA           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    RBRAKET         reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    EQCOMP          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    LESSTH          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    LESSEQTH        reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    GREATH          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    GREATEQTH       reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    NOTEQ           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    $end            reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    END             reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    RETURN          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    ELSE            reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    ELSIF           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    RPAREN          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    ID              reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    DEF             reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    IF              reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    UNLESS          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    CASE            reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    WHILE           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    INT             reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    FLOAT           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    RAT             reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    COMPX           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    COLON           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    DO              reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    WHEN            reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    THEN            reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    RBRACE          reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)


state 184

    (57) array -> LBRAKET ids COMMA objs RBRAKET .

    COMMA           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    RBRAKET         reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    EQCOMP          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    LESSTH          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    LESSEQTH        reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    GREATH          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    GREATEQTH       reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    NOTEQ           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    $end            reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    END             reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    RETURN          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    ELSE            reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    ELSIF           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    RPAREN          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    ID              reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    DEF             reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    IF              reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    UNLESS          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    CASE            reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    WHILE           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    INT             reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    FLOAT           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    RAT             reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    COMPX           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    COLON           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    DO              reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    WHEN            reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    THEN            reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    RBRACE          reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)


state 185

    (60) strucSet -> SET DOT NEW LPAREN array RPAREN .

    EQCOMP          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    LESSTH          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    LESSEQTH        reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    GREATH          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    GREATEQTH       reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    NOTEQ           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    $end            reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    END             reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    RETURN          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    ELSE            reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    ELSIF           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    COMMA           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    RPAREN          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    ID              reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    DEF             reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    IF              reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    UNLESS          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    CASE            reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    WHILE           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    INT             reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    FLOAT           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    RAT             reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    COMPX           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    COLON           reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    DO              reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    WHEN            reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    RBRAKET         reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    THEN            reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)
    RBRACE          reduce using rule 60 (strucSet -> SET DOT NEW LPAREN array RPAREN .)


state 186

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj . END

    END             shift and go to state 188


state 187

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .

    $end            reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    END             reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    RETURN          reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    ELSE            reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    ELSIF           reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)


state 188

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .

    $end            reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    END             reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    RETURN          reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    ELSE            reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    ELSIF           reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 93 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 111 resolved as shift
