Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AMPERS
    AND
    ARRAY
    AT
    BEGIN
    BOOLAND
    BOOLOR
    BREAK
    CLASS
    COMMENT
    DOLLARSGN
    DUODOT
    ENSURE
    FOR
    IN
    LBRACE
    MINUSEQ
    NEXT
    NOT
    OR
    PIPE
    PLUSEQ
    RBRACE
    RETRY
    SELF
    SEMICOLON
    SUPER
    TILDE
    TRIDOT
    UNDERSCR
    UNTIL
    WHILE

Grammar

Rule 0     S' -> init
Rule 1     init -> cmmd
Rule 2     bool -> TRUE
Rule 3     bool -> FALSE
Rule 4     num -> INT
Rule 5     num -> FLOAT
Rule 6     num -> RAT
Rule 7     num -> COMPX
Rule 8     optr -> PLUS
Rule 9     optr -> MINUS
Rule 10    optr -> TIMES
Rule 11    optr -> DIVIDE
Rule 12    optr -> MODULE
Rule 13    optr -> EXPON
Rule 14    optn -> num optr num
Rule 15    comptn -> obj comptr obj
Rule 16    comptr -> EQCOMP
Rule 17    comptr -> LESSTH
Rule 18    comptr -> LESSEQTH
Rule 19    comptr -> GREATH
Rule 20    comptr -> GREATEQTH
Rule 21    comptr -> NOTEQ
Rule 22    var -> ID EQUALS obj
Rule 23    var -> ID EQUALS ID
Rule 24    var -> ID EQUALS NIL
Rule 25    func -> DEF ID LPAREN objs RPAREN cmmd END
Rule 26    func -> DEF ID LPAREN RPAREN cmmd END
Rule 27    func -> DEF ID cmmd END
Rule 28    func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END
Rule 29    func -> DEF ID LPAREN RPAREN cmmd RETURN obj END
Rule 30    func -> DEF ID cmmd RETURN obj END
Rule 31    else -> ELSE comptn cmmd
Rule 32    else -> ELSE bool cmmd
Rule 33    elsif -> ELSIF comptn cmmd
Rule 34    elsif -> ELSIF bool cmmd
Rule 35    elses -> else
Rule 36    elses -> elsif elses
Rule 37    control -> IF comptn cmmd END
Rule 38    control -> IF bool cmmd END
Rule 39    control -> IF comptn cmmd elses END
Rule 40    control -> IF bool cmmd elses END
Rule 41    control -> UNLESS comptn COLON cmmd END
Rule 42    control -> UNLESS bool COLON cmmd END
Rule 43    control -> UNLESS comptn cmmd elses END
Rule 44    control -> UNLESS bool cmmd elses END
Rule 45    when -> WHEN objs
Rule 46    when -> WHEN objs THEN
Rule 47    when -> WHEN comptn
Rule 48    whens -> when
Rule 49    whens -> when whens
Rule 50    control -> CASE ID whens else END
Rule 51    control -> CASE ID whens END
Rule 52    ids -> ID
Rule 53    ids -> ID COMMA ids
Rule 54    array -> LBRAKET objs RBRAKET
Rule 55    array -> LBRAKET ids RBRAKET
Rule 56    array -> LBRAKET objs COMMA ids RBRAKET
Rule 57    array -> LBRAKET ids COMMA objs RBRAKET
Rule 58    struc -> SET DOT NEW
Rule 59    struc -> SET DOT NEW LPAREN RPAREN
Rule 60    struc -> SET DOT NEW LPAREN array RPAREN
Rule 61    struc -> SET array
Rule 62    objs -> obj
Rule 63    objs -> obj COMMA objs
Rule 64    obj -> STRING
Rule 65    obj -> num
Rule 66    obj -> bool
Rule 67    obj -> range
Rule 68    obj -> matrix
Rule 69    range -> LPAREN INT DOT DOT INT RPAREN
Rule 70    range -> INT DOT DOT INT
Rule 71    range -> LPAREN STRING DOT DOT STRING
Rule 72    range -> STRING DOT DOT STRING
Rule 73    cmmd -> var
Rule 74    cmmd -> func
Rule 75    cmmd -> control
Rule 76    cmmd -> optn
Rule 77    matrix -> LBRAKET rows RBRAKET
Rule 78    rows -> row
Rule 79    rows -> row COMMA rows
Rule 80    row -> array

Terminals, with rules where they appear

AMPERS               : 
AND                  : 
ARRAY                : 
AT                   : 
BEGIN                : 
BOOLAND              : 
BOOLOR               : 
BREAK                : 
CASE                 : 50 51
CLASS                : 
COLON                : 41 42
COMMA                : 53 56 57 63 79
COMMENT              : 
COMPX                : 7
DEF                  : 25 26 27 28 29 30
DIVIDE               : 11
DOLLARSGN            : 
DOT                  : 58 59 60 69 69 70 70 71 71 72 72
DUODOT               : 
ELSE                 : 31 32
ELSIF                : 33 34
END                  : 25 26 27 28 29 30 37 38 39 40 41 42 43 44 50 51
ENSURE               : 
EQCOMP               : 16
EQUALS               : 22 23 24
EXPON                : 13
FALSE                : 3
FLOAT                : 5
FOR                  : 
GREATEQTH            : 20
GREATH               : 19
ID                   : 22 23 23 24 25 26 27 28 29 30 50 51 52 53
IF                   : 37 38 39 40
IN                   : 
INT                  : 4 69 69 70 70
LBRACE               : 
LBRAKET              : 54 55 56 57 77
LESSEQTH             : 18
LESSTH               : 17
LPAREN               : 25 26 28 29 59 60 69 71
MINUS                : 9
MINUSEQ              : 
MODULE               : 12
NEW                  : 58 59 60
NEXT                 : 
NIL                  : 24
NOT                  : 
NOTEQ                : 21
OR                   : 
PIPE                 : 
PLUS                 : 8
PLUSEQ               : 
RAT                  : 6
RBRACE               : 
RBRAKET              : 54 55 56 57 77
RETRY                : 
RETURN               : 28 29 30
RPAREN               : 25 26 28 29 59 60 69
SELF                 : 
SEMICOLON            : 
SET                  : 58 59 60 61
STRING               : 64 71 71 72 72
SUPER                : 
THEN                 : 46
TILDE                : 
TIMES                : 10
TRIDOT               : 
TRUE                 : 2
UNDERSCR             : 
UNLESS               : 41 42 43 44
UNTIL                : 
WHEN                 : 45 46 47
WHILE                : 
error                : 

Nonterminals, with rules where they appear

array                : 60 61 80
bool                 : 32 34 38 40 42 44 66
cmmd                 : 1 25 26 27 28 29 30 31 32 33 34 37 38 39 40 41 42 43 44
comptn               : 31 33 37 39 41 43 47
comptr               : 15
control              : 75
else                 : 35 50
elses                : 36 39 40 43 44
elsif                : 36
func                 : 74
ids                  : 53 55 56 57
init                 : 0
matrix               : 68
num                  : 14 14 65
obj                  : 15 15 22 28 29 30 62 63
objs                 : 25 28 45 46 54 56 57 63
optn                 : 76
optr                 : 14
range                : 67
row                  : 78 79
rows                 : 77 79
struc                : 
var                  : 73
when                 : 48 49
whens                : 49 50 51

Parsing method: LALR

state 0

    (0) S' -> . init
    (1) init -> . cmmd
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    init                           shift and go to state 1
    cmmd                           shift and go to state 2
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 1

    (0) S' -> init .



state 2

    (1) init -> cmmd .

    $end            reduce using rule 1 (init -> cmmd .)


state 3

    (73) cmmd -> var .

    $end            reduce using rule 73 (cmmd -> var .)
    END             reduce using rule 73 (cmmd -> var .)
    RETURN          reduce using rule 73 (cmmd -> var .)
    ELSE            reduce using rule 73 (cmmd -> var .)
    ELSIF           reduce using rule 73 (cmmd -> var .)


state 4

    (74) cmmd -> func .

    $end            reduce using rule 74 (cmmd -> func .)
    END             reduce using rule 74 (cmmd -> func .)
    RETURN          reduce using rule 74 (cmmd -> func .)
    ELSE            reduce using rule 74 (cmmd -> func .)
    ELSIF           reduce using rule 74 (cmmd -> func .)


state 5

    (75) cmmd -> control .

    $end            reduce using rule 75 (cmmd -> control .)
    END             reduce using rule 75 (cmmd -> control .)
    RETURN          reduce using rule 75 (cmmd -> control .)
    ELSE            reduce using rule 75 (cmmd -> control .)
    ELSIF           reduce using rule 75 (cmmd -> control .)


state 6

    (76) cmmd -> optn .

    $end            reduce using rule 76 (cmmd -> optn .)
    END             reduce using rule 76 (cmmd -> optn .)
    RETURN          reduce using rule 76 (cmmd -> optn .)
    ELSE            reduce using rule 76 (cmmd -> optn .)
    ELSIF           reduce using rule 76 (cmmd -> optn .)


state 7

    (22) var -> ID . EQUALS obj
    (23) var -> ID . EQUALS ID
    (24) var -> ID . EQUALS NIL

    EQUALS          shift and go to state 17


state 8

    (25) func -> DEF . ID LPAREN objs RPAREN cmmd END
    (26) func -> DEF . ID LPAREN RPAREN cmmd END
    (27) func -> DEF . ID cmmd END
    (28) func -> DEF . ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> DEF . ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> DEF . ID cmmd RETURN obj END

    ID              shift and go to state 18


state 9

    (37) control -> IF . comptn cmmd END
    (38) control -> IF . bool cmmd END
    (39) control -> IF . comptn cmmd elses END
    (40) control -> IF . bool cmmd elses END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    comptn                         shift and go to state 19
    bool                           shift and go to state 20
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 10

    (41) control -> UNLESS . comptn COLON cmmd END
    (42) control -> UNLESS . bool COLON cmmd END
    (43) control -> UNLESS . comptn cmmd elses END
    (44) control -> UNLESS . bool cmmd elses END
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    comptn                         shift and go to state 31
    bool                           shift and go to state 32
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 11

    (50) control -> CASE . ID whens else END
    (51) control -> CASE . ID whens END

    ID              shift and go to state 33


state 12

    (14) optn -> num . optr num
    (8) optr -> . PLUS
    (9) optr -> . MINUS
    (10) optr -> . TIMES
    (11) optr -> . DIVIDE
    (12) optr -> . MODULE
    (13) optr -> . EXPON

    PLUS            shift and go to state 35
    MINUS           shift and go to state 36
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38
    MODULE          shift and go to state 39
    EXPON           shift and go to state 40

    optr                           shift and go to state 34

state 13

    (4) num -> INT .

    PLUS            reduce using rule 4 (num -> INT .)
    MINUS           reduce using rule 4 (num -> INT .)
    TIMES           reduce using rule 4 (num -> INT .)
    DIVIDE          reduce using rule 4 (num -> INT .)
    MODULE          reduce using rule 4 (num -> INT .)
    EXPON           reduce using rule 4 (num -> INT .)
    $end            reduce using rule 4 (num -> INT .)
    END             reduce using rule 4 (num -> INT .)
    RETURN          reduce using rule 4 (num -> INT .)
    ELSE            reduce using rule 4 (num -> INT .)
    ELSIF           reduce using rule 4 (num -> INT .)


state 14

    (5) num -> FLOAT .

    PLUS            reduce using rule 5 (num -> FLOAT .)
    MINUS           reduce using rule 5 (num -> FLOAT .)
    TIMES           reduce using rule 5 (num -> FLOAT .)
    DIVIDE          reduce using rule 5 (num -> FLOAT .)
    MODULE          reduce using rule 5 (num -> FLOAT .)
    EXPON           reduce using rule 5 (num -> FLOAT .)
    EQCOMP          reduce using rule 5 (num -> FLOAT .)
    LESSTH          reduce using rule 5 (num -> FLOAT .)
    LESSEQTH        reduce using rule 5 (num -> FLOAT .)
    GREATH          reduce using rule 5 (num -> FLOAT .)
    GREATEQTH       reduce using rule 5 (num -> FLOAT .)
    NOTEQ           reduce using rule 5 (num -> FLOAT .)
    $end            reduce using rule 5 (num -> FLOAT .)
    END             reduce using rule 5 (num -> FLOAT .)
    RETURN          reduce using rule 5 (num -> FLOAT .)
    ELSE            reduce using rule 5 (num -> FLOAT .)
    ELSIF           reduce using rule 5 (num -> FLOAT .)
    COMMA           reduce using rule 5 (num -> FLOAT .)
    RPAREN          reduce using rule 5 (num -> FLOAT .)
    ID              reduce using rule 5 (num -> FLOAT .)
    DEF             reduce using rule 5 (num -> FLOAT .)
    IF              reduce using rule 5 (num -> FLOAT .)
    UNLESS          reduce using rule 5 (num -> FLOAT .)
    CASE            reduce using rule 5 (num -> FLOAT .)
    INT             reduce using rule 5 (num -> FLOAT .)
    FLOAT           reduce using rule 5 (num -> FLOAT .)
    RAT             reduce using rule 5 (num -> FLOAT .)
    COMPX           reduce using rule 5 (num -> FLOAT .)
    COLON           reduce using rule 5 (num -> FLOAT .)
    WHEN            reduce using rule 5 (num -> FLOAT .)
    RBRAKET         reduce using rule 5 (num -> FLOAT .)
    THEN            reduce using rule 5 (num -> FLOAT .)


state 15

    (6) num -> RAT .

    PLUS            reduce using rule 6 (num -> RAT .)
    MINUS           reduce using rule 6 (num -> RAT .)
    TIMES           reduce using rule 6 (num -> RAT .)
    DIVIDE          reduce using rule 6 (num -> RAT .)
    MODULE          reduce using rule 6 (num -> RAT .)
    EXPON           reduce using rule 6 (num -> RAT .)
    EQCOMP          reduce using rule 6 (num -> RAT .)
    LESSTH          reduce using rule 6 (num -> RAT .)
    LESSEQTH        reduce using rule 6 (num -> RAT .)
    GREATH          reduce using rule 6 (num -> RAT .)
    GREATEQTH       reduce using rule 6 (num -> RAT .)
    NOTEQ           reduce using rule 6 (num -> RAT .)
    $end            reduce using rule 6 (num -> RAT .)
    END             reduce using rule 6 (num -> RAT .)
    RETURN          reduce using rule 6 (num -> RAT .)
    ELSE            reduce using rule 6 (num -> RAT .)
    ELSIF           reduce using rule 6 (num -> RAT .)
    COMMA           reduce using rule 6 (num -> RAT .)
    RPAREN          reduce using rule 6 (num -> RAT .)
    ID              reduce using rule 6 (num -> RAT .)
    DEF             reduce using rule 6 (num -> RAT .)
    IF              reduce using rule 6 (num -> RAT .)
    UNLESS          reduce using rule 6 (num -> RAT .)
    CASE            reduce using rule 6 (num -> RAT .)
    INT             reduce using rule 6 (num -> RAT .)
    FLOAT           reduce using rule 6 (num -> RAT .)
    RAT             reduce using rule 6 (num -> RAT .)
    COMPX           reduce using rule 6 (num -> RAT .)
    COLON           reduce using rule 6 (num -> RAT .)
    WHEN            reduce using rule 6 (num -> RAT .)
    RBRAKET         reduce using rule 6 (num -> RAT .)
    THEN            reduce using rule 6 (num -> RAT .)


state 16

    (7) num -> COMPX .

    PLUS            reduce using rule 7 (num -> COMPX .)
    MINUS           reduce using rule 7 (num -> COMPX .)
    TIMES           reduce using rule 7 (num -> COMPX .)
    DIVIDE          reduce using rule 7 (num -> COMPX .)
    MODULE          reduce using rule 7 (num -> COMPX .)
    EXPON           reduce using rule 7 (num -> COMPX .)
    EQCOMP          reduce using rule 7 (num -> COMPX .)
    LESSTH          reduce using rule 7 (num -> COMPX .)
    LESSEQTH        reduce using rule 7 (num -> COMPX .)
    GREATH          reduce using rule 7 (num -> COMPX .)
    GREATEQTH       reduce using rule 7 (num -> COMPX .)
    NOTEQ           reduce using rule 7 (num -> COMPX .)
    $end            reduce using rule 7 (num -> COMPX .)
    END             reduce using rule 7 (num -> COMPX .)
    RETURN          reduce using rule 7 (num -> COMPX .)
    ELSE            reduce using rule 7 (num -> COMPX .)
    ELSIF           reduce using rule 7 (num -> COMPX .)
    COMMA           reduce using rule 7 (num -> COMPX .)
    RPAREN          reduce using rule 7 (num -> COMPX .)
    ID              reduce using rule 7 (num -> COMPX .)
    DEF             reduce using rule 7 (num -> COMPX .)
    IF              reduce using rule 7 (num -> COMPX .)
    UNLESS          reduce using rule 7 (num -> COMPX .)
    CASE            reduce using rule 7 (num -> COMPX .)
    INT             reduce using rule 7 (num -> COMPX .)
    FLOAT           reduce using rule 7 (num -> COMPX .)
    RAT             reduce using rule 7 (num -> COMPX .)
    COMPX           reduce using rule 7 (num -> COMPX .)
    COLON           reduce using rule 7 (num -> COMPX .)
    WHEN            reduce using rule 7 (num -> COMPX .)
    RBRAKET         reduce using rule 7 (num -> COMPX .)
    THEN            reduce using rule 7 (num -> COMPX .)


state 17

    (22) var -> ID EQUALS . obj
    (23) var -> ID EQUALS . ID
    (24) var -> ID EQUALS . NIL
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    ID              shift and go to state 41
    NIL             shift and go to state 43
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    obj                            shift and go to state 42
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 18

    (25) func -> DEF ID . LPAREN objs RPAREN cmmd END
    (26) func -> DEF ID . LPAREN RPAREN cmmd END
    (27) func -> DEF ID . cmmd END
    (28) func -> DEF ID . LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> DEF ID . LPAREN RPAREN cmmd RETURN obj END
    (30) func -> DEF ID . cmmd RETURN obj END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    LPAREN          shift and go to state 45
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 46
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 19

    (37) control -> IF comptn . cmmd END
    (39) control -> IF comptn . cmmd elses END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 47
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 20

    (38) control -> IF bool . cmmd END
    (40) control -> IF bool . cmmd elses END
    (66) obj -> bool .
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 48
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 21

    (15) comptn -> obj . comptr obj
    (16) comptr -> . EQCOMP
    (17) comptr -> . LESSTH
    (18) comptr -> . LESSEQTH
    (19) comptr -> . GREATH
    (20) comptr -> . GREATEQTH
    (21) comptr -> . NOTEQ

    EQCOMP          shift and go to state 50
    LESSTH          shift and go to state 51
    LESSEQTH        shift and go to state 52
    GREATH          shift and go to state 53
    GREATEQTH       shift and go to state 54
    NOTEQ           shift and go to state 55

    comptr                         shift and go to state 49

state 22

    (2) bool -> TRUE .

    ID              reduce using rule 2 (bool -> TRUE .)
    DEF             reduce using rule 2 (bool -> TRUE .)
    IF              reduce using rule 2 (bool -> TRUE .)
    UNLESS          reduce using rule 2 (bool -> TRUE .)
    CASE            reduce using rule 2 (bool -> TRUE .)
    INT             reduce using rule 2 (bool -> TRUE .)
    FLOAT           reduce using rule 2 (bool -> TRUE .)
    RAT             reduce using rule 2 (bool -> TRUE .)
    COMPX           reduce using rule 2 (bool -> TRUE .)
    EQCOMP          reduce using rule 2 (bool -> TRUE .)
    LESSTH          reduce using rule 2 (bool -> TRUE .)
    LESSEQTH        reduce using rule 2 (bool -> TRUE .)
    GREATH          reduce using rule 2 (bool -> TRUE .)
    GREATEQTH       reduce using rule 2 (bool -> TRUE .)
    NOTEQ           reduce using rule 2 (bool -> TRUE .)
    COLON           reduce using rule 2 (bool -> TRUE .)
    $end            reduce using rule 2 (bool -> TRUE .)
    END             reduce using rule 2 (bool -> TRUE .)
    RETURN          reduce using rule 2 (bool -> TRUE .)
    ELSE            reduce using rule 2 (bool -> TRUE .)
    ELSIF           reduce using rule 2 (bool -> TRUE .)
    COMMA           reduce using rule 2 (bool -> TRUE .)
    RPAREN          reduce using rule 2 (bool -> TRUE .)
    WHEN            reduce using rule 2 (bool -> TRUE .)
    RBRAKET         reduce using rule 2 (bool -> TRUE .)
    THEN            reduce using rule 2 (bool -> TRUE .)


state 23

    (3) bool -> FALSE .

    ID              reduce using rule 3 (bool -> FALSE .)
    DEF             reduce using rule 3 (bool -> FALSE .)
    IF              reduce using rule 3 (bool -> FALSE .)
    UNLESS          reduce using rule 3 (bool -> FALSE .)
    CASE            reduce using rule 3 (bool -> FALSE .)
    INT             reduce using rule 3 (bool -> FALSE .)
    FLOAT           reduce using rule 3 (bool -> FALSE .)
    RAT             reduce using rule 3 (bool -> FALSE .)
    COMPX           reduce using rule 3 (bool -> FALSE .)
    EQCOMP          reduce using rule 3 (bool -> FALSE .)
    LESSTH          reduce using rule 3 (bool -> FALSE .)
    LESSEQTH        reduce using rule 3 (bool -> FALSE .)
    GREATH          reduce using rule 3 (bool -> FALSE .)
    GREATEQTH       reduce using rule 3 (bool -> FALSE .)
    NOTEQ           reduce using rule 3 (bool -> FALSE .)
    COLON           reduce using rule 3 (bool -> FALSE .)
    $end            reduce using rule 3 (bool -> FALSE .)
    END             reduce using rule 3 (bool -> FALSE .)
    RETURN          reduce using rule 3 (bool -> FALSE .)
    ELSE            reduce using rule 3 (bool -> FALSE .)
    ELSIF           reduce using rule 3 (bool -> FALSE .)
    COMMA           reduce using rule 3 (bool -> FALSE .)
    RPAREN          reduce using rule 3 (bool -> FALSE .)
    WHEN            reduce using rule 3 (bool -> FALSE .)
    RBRAKET         reduce using rule 3 (bool -> FALSE .)
    THEN            reduce using rule 3 (bool -> FALSE .)


state 24

    (64) obj -> STRING .
    (72) range -> STRING . DOT DOT STRING

    EQCOMP          reduce using rule 64 (obj -> STRING .)
    LESSTH          reduce using rule 64 (obj -> STRING .)
    LESSEQTH        reduce using rule 64 (obj -> STRING .)
    GREATH          reduce using rule 64 (obj -> STRING .)
    GREATEQTH       reduce using rule 64 (obj -> STRING .)
    NOTEQ           reduce using rule 64 (obj -> STRING .)
    $end            reduce using rule 64 (obj -> STRING .)
    END             reduce using rule 64 (obj -> STRING .)
    RETURN          reduce using rule 64 (obj -> STRING .)
    ELSE            reduce using rule 64 (obj -> STRING .)
    ELSIF           reduce using rule 64 (obj -> STRING .)
    COMMA           reduce using rule 64 (obj -> STRING .)
    RPAREN          reduce using rule 64 (obj -> STRING .)
    ID              reduce using rule 64 (obj -> STRING .)
    DEF             reduce using rule 64 (obj -> STRING .)
    IF              reduce using rule 64 (obj -> STRING .)
    UNLESS          reduce using rule 64 (obj -> STRING .)
    CASE            reduce using rule 64 (obj -> STRING .)
    INT             reduce using rule 64 (obj -> STRING .)
    FLOAT           reduce using rule 64 (obj -> STRING .)
    RAT             reduce using rule 64 (obj -> STRING .)
    COMPX           reduce using rule 64 (obj -> STRING .)
    COLON           reduce using rule 64 (obj -> STRING .)
    WHEN            reduce using rule 64 (obj -> STRING .)
    RBRAKET         reduce using rule 64 (obj -> STRING .)
    THEN            reduce using rule 64 (obj -> STRING .)
    DOT             shift and go to state 56


state 25

    (65) obj -> num .

    EQCOMP          reduce using rule 65 (obj -> num .)
    LESSTH          reduce using rule 65 (obj -> num .)
    LESSEQTH        reduce using rule 65 (obj -> num .)
    GREATH          reduce using rule 65 (obj -> num .)
    GREATEQTH       reduce using rule 65 (obj -> num .)
    NOTEQ           reduce using rule 65 (obj -> num .)
    $end            reduce using rule 65 (obj -> num .)
    END             reduce using rule 65 (obj -> num .)
    RETURN          reduce using rule 65 (obj -> num .)
    ELSE            reduce using rule 65 (obj -> num .)
    ELSIF           reduce using rule 65 (obj -> num .)
    COMMA           reduce using rule 65 (obj -> num .)
    RPAREN          reduce using rule 65 (obj -> num .)
    ID              reduce using rule 65 (obj -> num .)
    DEF             reduce using rule 65 (obj -> num .)
    IF              reduce using rule 65 (obj -> num .)
    UNLESS          reduce using rule 65 (obj -> num .)
    CASE            reduce using rule 65 (obj -> num .)
    INT             reduce using rule 65 (obj -> num .)
    FLOAT           reduce using rule 65 (obj -> num .)
    RAT             reduce using rule 65 (obj -> num .)
    COMPX           reduce using rule 65 (obj -> num .)
    COLON           reduce using rule 65 (obj -> num .)
    WHEN            reduce using rule 65 (obj -> num .)
    RBRAKET         reduce using rule 65 (obj -> num .)
    THEN            reduce using rule 65 (obj -> num .)


state 26

    (67) obj -> range .

    EQCOMP          reduce using rule 67 (obj -> range .)
    LESSTH          reduce using rule 67 (obj -> range .)
    LESSEQTH        reduce using rule 67 (obj -> range .)
    GREATH          reduce using rule 67 (obj -> range .)
    GREATEQTH       reduce using rule 67 (obj -> range .)
    NOTEQ           reduce using rule 67 (obj -> range .)
    $end            reduce using rule 67 (obj -> range .)
    END             reduce using rule 67 (obj -> range .)
    RETURN          reduce using rule 67 (obj -> range .)
    ELSE            reduce using rule 67 (obj -> range .)
    ELSIF           reduce using rule 67 (obj -> range .)
    COMMA           reduce using rule 67 (obj -> range .)
    RPAREN          reduce using rule 67 (obj -> range .)
    ID              reduce using rule 67 (obj -> range .)
    DEF             reduce using rule 67 (obj -> range .)
    IF              reduce using rule 67 (obj -> range .)
    UNLESS          reduce using rule 67 (obj -> range .)
    CASE            reduce using rule 67 (obj -> range .)
    INT             reduce using rule 67 (obj -> range .)
    FLOAT           reduce using rule 67 (obj -> range .)
    RAT             reduce using rule 67 (obj -> range .)
    COMPX           reduce using rule 67 (obj -> range .)
    COLON           reduce using rule 67 (obj -> range .)
    WHEN            reduce using rule 67 (obj -> range .)
    RBRAKET         reduce using rule 67 (obj -> range .)
    THEN            reduce using rule 67 (obj -> range .)


state 27

    (68) obj -> matrix .

    EQCOMP          reduce using rule 68 (obj -> matrix .)
    LESSTH          reduce using rule 68 (obj -> matrix .)
    LESSEQTH        reduce using rule 68 (obj -> matrix .)
    GREATH          reduce using rule 68 (obj -> matrix .)
    GREATEQTH       reduce using rule 68 (obj -> matrix .)
    NOTEQ           reduce using rule 68 (obj -> matrix .)
    $end            reduce using rule 68 (obj -> matrix .)
    END             reduce using rule 68 (obj -> matrix .)
    RETURN          reduce using rule 68 (obj -> matrix .)
    ELSE            reduce using rule 68 (obj -> matrix .)
    ELSIF           reduce using rule 68 (obj -> matrix .)
    COMMA           reduce using rule 68 (obj -> matrix .)
    RPAREN          reduce using rule 68 (obj -> matrix .)
    ID              reduce using rule 68 (obj -> matrix .)
    DEF             reduce using rule 68 (obj -> matrix .)
    IF              reduce using rule 68 (obj -> matrix .)
    UNLESS          reduce using rule 68 (obj -> matrix .)
    CASE            reduce using rule 68 (obj -> matrix .)
    INT             reduce using rule 68 (obj -> matrix .)
    FLOAT           reduce using rule 68 (obj -> matrix .)
    RAT             reduce using rule 68 (obj -> matrix .)
    COMPX           reduce using rule 68 (obj -> matrix .)
    COLON           reduce using rule 68 (obj -> matrix .)
    WHEN            reduce using rule 68 (obj -> matrix .)
    RBRAKET         reduce using rule 68 (obj -> matrix .)
    THEN            reduce using rule 68 (obj -> matrix .)


state 28

    (4) num -> INT .
    (70) range -> INT . DOT DOT INT

    EQCOMP          reduce using rule 4 (num -> INT .)
    LESSTH          reduce using rule 4 (num -> INT .)
    LESSEQTH        reduce using rule 4 (num -> INT .)
    GREATH          reduce using rule 4 (num -> INT .)
    GREATEQTH       reduce using rule 4 (num -> INT .)
    NOTEQ           reduce using rule 4 (num -> INT .)
    $end            reduce using rule 4 (num -> INT .)
    END             reduce using rule 4 (num -> INT .)
    RETURN          reduce using rule 4 (num -> INT .)
    ELSE            reduce using rule 4 (num -> INT .)
    ELSIF           reduce using rule 4 (num -> INT .)
    COMMA           reduce using rule 4 (num -> INT .)
    RPAREN          reduce using rule 4 (num -> INT .)
    ID              reduce using rule 4 (num -> INT .)
    DEF             reduce using rule 4 (num -> INT .)
    IF              reduce using rule 4 (num -> INT .)
    UNLESS          reduce using rule 4 (num -> INT .)
    CASE            reduce using rule 4 (num -> INT .)
    INT             reduce using rule 4 (num -> INT .)
    FLOAT           reduce using rule 4 (num -> INT .)
    RAT             reduce using rule 4 (num -> INT .)
    COMPX           reduce using rule 4 (num -> INT .)
    COLON           reduce using rule 4 (num -> INT .)
    WHEN            reduce using rule 4 (num -> INT .)
    RBRAKET         reduce using rule 4 (num -> INT .)
    THEN            reduce using rule 4 (num -> INT .)
    DOT             shift and go to state 57


state 29

    (69) range -> LPAREN . INT DOT DOT INT RPAREN
    (71) range -> LPAREN . STRING DOT DOT STRING

    INT             shift and go to state 58
    STRING          shift and go to state 59


state 30

    (77) matrix -> LBRAKET . rows RBRAKET
    (78) rows -> . row
    (79) rows -> . row COMMA rows
    (80) row -> . array
    (54) array -> . LBRAKET objs RBRAKET
    (55) array -> . LBRAKET ids RBRAKET
    (56) array -> . LBRAKET objs COMMA ids RBRAKET
    (57) array -> . LBRAKET ids COMMA objs RBRAKET

    LBRAKET         shift and go to state 60

    rows                           shift and go to state 61
    row                            shift and go to state 62
    array                          shift and go to state 63

state 31

    (41) control -> UNLESS comptn . COLON cmmd END
    (43) control -> UNLESS comptn . cmmd elses END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    COLON           shift and go to state 64
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 65
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 32

    (42) control -> UNLESS bool . COLON cmmd END
    (44) control -> UNLESS bool . cmmd elses END
    (66) obj -> bool .
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    COLON           shift and go to state 66
    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 67
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 33

    (50) control -> CASE ID . whens else END
    (51) control -> CASE ID . whens END
    (48) whens -> . when
    (49) whens -> . when whens
    (45) when -> . WHEN objs
    (46) when -> . WHEN objs THEN
    (47) when -> . WHEN comptn

    WHEN            shift and go to state 70

    whens                          shift and go to state 68
    when                           shift and go to state 69

state 34

    (14) optn -> num optr . num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    num                            shift and go to state 71

state 35

    (8) optr -> PLUS .

    INT             reduce using rule 8 (optr -> PLUS .)
    FLOAT           reduce using rule 8 (optr -> PLUS .)
    RAT             reduce using rule 8 (optr -> PLUS .)
    COMPX           reduce using rule 8 (optr -> PLUS .)


state 36

    (9) optr -> MINUS .

    INT             reduce using rule 9 (optr -> MINUS .)
    FLOAT           reduce using rule 9 (optr -> MINUS .)
    RAT             reduce using rule 9 (optr -> MINUS .)
    COMPX           reduce using rule 9 (optr -> MINUS .)


state 37

    (10) optr -> TIMES .

    INT             reduce using rule 10 (optr -> TIMES .)
    FLOAT           reduce using rule 10 (optr -> TIMES .)
    RAT             reduce using rule 10 (optr -> TIMES .)
    COMPX           reduce using rule 10 (optr -> TIMES .)


state 38

    (11) optr -> DIVIDE .

    INT             reduce using rule 11 (optr -> DIVIDE .)
    FLOAT           reduce using rule 11 (optr -> DIVIDE .)
    RAT             reduce using rule 11 (optr -> DIVIDE .)
    COMPX           reduce using rule 11 (optr -> DIVIDE .)


state 39

    (12) optr -> MODULE .

    INT             reduce using rule 12 (optr -> MODULE .)
    FLOAT           reduce using rule 12 (optr -> MODULE .)
    RAT             reduce using rule 12 (optr -> MODULE .)
    COMPX           reduce using rule 12 (optr -> MODULE .)


state 40

    (13) optr -> EXPON .

    INT             reduce using rule 13 (optr -> EXPON .)
    FLOAT           reduce using rule 13 (optr -> EXPON .)
    RAT             reduce using rule 13 (optr -> EXPON .)
    COMPX           reduce using rule 13 (optr -> EXPON .)


state 41

    (23) var -> ID EQUALS ID .

    $end            reduce using rule 23 (var -> ID EQUALS ID .)
    END             reduce using rule 23 (var -> ID EQUALS ID .)
    RETURN          reduce using rule 23 (var -> ID EQUALS ID .)
    ELSE            reduce using rule 23 (var -> ID EQUALS ID .)
    ELSIF           reduce using rule 23 (var -> ID EQUALS ID .)


state 42

    (22) var -> ID EQUALS obj .

    $end            reduce using rule 22 (var -> ID EQUALS obj .)
    END             reduce using rule 22 (var -> ID EQUALS obj .)
    RETURN          reduce using rule 22 (var -> ID EQUALS obj .)
    ELSE            reduce using rule 22 (var -> ID EQUALS obj .)
    ELSIF           reduce using rule 22 (var -> ID EQUALS obj .)


state 43

    (24) var -> ID EQUALS NIL .

    $end            reduce using rule 24 (var -> ID EQUALS NIL .)
    END             reduce using rule 24 (var -> ID EQUALS NIL .)
    RETURN          reduce using rule 24 (var -> ID EQUALS NIL .)
    ELSE            reduce using rule 24 (var -> ID EQUALS NIL .)
    ELSIF           reduce using rule 24 (var -> ID EQUALS NIL .)


state 44

    (66) obj -> bool .

    $end            reduce using rule 66 (obj -> bool .)
    END             reduce using rule 66 (obj -> bool .)
    RETURN          reduce using rule 66 (obj -> bool .)
    ELSE            reduce using rule 66 (obj -> bool .)
    ELSIF           reduce using rule 66 (obj -> bool .)
    COMMA           reduce using rule 66 (obj -> bool .)
    RPAREN          reduce using rule 66 (obj -> bool .)
    ID              reduce using rule 66 (obj -> bool .)
    DEF             reduce using rule 66 (obj -> bool .)
    IF              reduce using rule 66 (obj -> bool .)
    UNLESS          reduce using rule 66 (obj -> bool .)
    CASE            reduce using rule 66 (obj -> bool .)
    INT             reduce using rule 66 (obj -> bool .)
    FLOAT           reduce using rule 66 (obj -> bool .)
    RAT             reduce using rule 66 (obj -> bool .)
    COMPX           reduce using rule 66 (obj -> bool .)
    COLON           reduce using rule 66 (obj -> bool .)
    WHEN            reduce using rule 66 (obj -> bool .)
    RBRAKET         reduce using rule 66 (obj -> bool .)
    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    THEN            reduce using rule 66 (obj -> bool .)


state 45

    (25) func -> DEF ID LPAREN . objs RPAREN cmmd END
    (26) func -> DEF ID LPAREN . RPAREN cmmd END
    (28) func -> DEF ID LPAREN . objs RPAREN cmmd RETURN obj END
    (29) func -> DEF ID LPAREN . RPAREN cmmd RETURN obj END
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    RPAREN          shift and go to state 73
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    objs                           shift and go to state 72
    obj                            shift and go to state 74
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 46

    (27) func -> DEF ID cmmd . END
    (30) func -> DEF ID cmmd . RETURN obj END

    END             shift and go to state 75
    RETURN          shift and go to state 76


state 47

    (37) control -> IF comptn cmmd . END
    (39) control -> IF comptn cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    END             shift and go to state 77
    ELSE            shift and go to state 81
    ELSIF           shift and go to state 82

    elses                          shift and go to state 78
    else                           shift and go to state 79
    elsif                          shift and go to state 80

state 48

    (38) control -> IF bool cmmd . END
    (40) control -> IF bool cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    END             shift and go to state 83
    ELSE            shift and go to state 81
    ELSIF           shift and go to state 82

    elses                          shift and go to state 84
    else                           shift and go to state 79
    elsif                          shift and go to state 80

state 49

    (15) comptn -> obj comptr . obj
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    obj                            shift and go to state 85
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 50

    (16) comptr -> EQCOMP .

    STRING          reduce using rule 16 (comptr -> EQCOMP .)
    INT             reduce using rule 16 (comptr -> EQCOMP .)
    FLOAT           reduce using rule 16 (comptr -> EQCOMP .)
    RAT             reduce using rule 16 (comptr -> EQCOMP .)
    COMPX           reduce using rule 16 (comptr -> EQCOMP .)
    TRUE            reduce using rule 16 (comptr -> EQCOMP .)
    FALSE           reduce using rule 16 (comptr -> EQCOMP .)
    LPAREN          reduce using rule 16 (comptr -> EQCOMP .)
    LBRAKET         reduce using rule 16 (comptr -> EQCOMP .)


state 51

    (17) comptr -> LESSTH .

    STRING          reduce using rule 17 (comptr -> LESSTH .)
    INT             reduce using rule 17 (comptr -> LESSTH .)
    FLOAT           reduce using rule 17 (comptr -> LESSTH .)
    RAT             reduce using rule 17 (comptr -> LESSTH .)
    COMPX           reduce using rule 17 (comptr -> LESSTH .)
    TRUE            reduce using rule 17 (comptr -> LESSTH .)
    FALSE           reduce using rule 17 (comptr -> LESSTH .)
    LPAREN          reduce using rule 17 (comptr -> LESSTH .)
    LBRAKET         reduce using rule 17 (comptr -> LESSTH .)


state 52

    (18) comptr -> LESSEQTH .

    STRING          reduce using rule 18 (comptr -> LESSEQTH .)
    INT             reduce using rule 18 (comptr -> LESSEQTH .)
    FLOAT           reduce using rule 18 (comptr -> LESSEQTH .)
    RAT             reduce using rule 18 (comptr -> LESSEQTH .)
    COMPX           reduce using rule 18 (comptr -> LESSEQTH .)
    TRUE            reduce using rule 18 (comptr -> LESSEQTH .)
    FALSE           reduce using rule 18 (comptr -> LESSEQTH .)
    LPAREN          reduce using rule 18 (comptr -> LESSEQTH .)
    LBRAKET         reduce using rule 18 (comptr -> LESSEQTH .)


state 53

    (19) comptr -> GREATH .

    STRING          reduce using rule 19 (comptr -> GREATH .)
    INT             reduce using rule 19 (comptr -> GREATH .)
    FLOAT           reduce using rule 19 (comptr -> GREATH .)
    RAT             reduce using rule 19 (comptr -> GREATH .)
    COMPX           reduce using rule 19 (comptr -> GREATH .)
    TRUE            reduce using rule 19 (comptr -> GREATH .)
    FALSE           reduce using rule 19 (comptr -> GREATH .)
    LPAREN          reduce using rule 19 (comptr -> GREATH .)
    LBRAKET         reduce using rule 19 (comptr -> GREATH .)


state 54

    (20) comptr -> GREATEQTH .

    STRING          reduce using rule 20 (comptr -> GREATEQTH .)
    INT             reduce using rule 20 (comptr -> GREATEQTH .)
    FLOAT           reduce using rule 20 (comptr -> GREATEQTH .)
    RAT             reduce using rule 20 (comptr -> GREATEQTH .)
    COMPX           reduce using rule 20 (comptr -> GREATEQTH .)
    TRUE            reduce using rule 20 (comptr -> GREATEQTH .)
    FALSE           reduce using rule 20 (comptr -> GREATEQTH .)
    LPAREN          reduce using rule 20 (comptr -> GREATEQTH .)
    LBRAKET         reduce using rule 20 (comptr -> GREATEQTH .)


state 55

    (21) comptr -> NOTEQ .

    STRING          reduce using rule 21 (comptr -> NOTEQ .)
    INT             reduce using rule 21 (comptr -> NOTEQ .)
    FLOAT           reduce using rule 21 (comptr -> NOTEQ .)
    RAT             reduce using rule 21 (comptr -> NOTEQ .)
    COMPX           reduce using rule 21 (comptr -> NOTEQ .)
    TRUE            reduce using rule 21 (comptr -> NOTEQ .)
    FALSE           reduce using rule 21 (comptr -> NOTEQ .)
    LPAREN          reduce using rule 21 (comptr -> NOTEQ .)
    LBRAKET         reduce using rule 21 (comptr -> NOTEQ .)


state 56

    (72) range -> STRING DOT . DOT STRING

    DOT             shift and go to state 86


state 57

    (70) range -> INT DOT . DOT INT

    DOT             shift and go to state 87


state 58

    (69) range -> LPAREN INT . DOT DOT INT RPAREN

    DOT             shift and go to state 88


state 59

    (71) range -> LPAREN STRING . DOT DOT STRING

    DOT             shift and go to state 89


state 60

    (54) array -> LBRAKET . objs RBRAKET
    (55) array -> LBRAKET . ids RBRAKET
    (56) array -> LBRAKET . objs COMMA ids RBRAKET
    (57) array -> LBRAKET . ids COMMA objs RBRAKET
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (52) ids -> . ID
    (53) ids -> . ID COMMA ids
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    ID              shift and go to state 92
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    objs                           shift and go to state 90
    ids                            shift and go to state 91
    obj                            shift and go to state 74
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 61

    (77) matrix -> LBRAKET rows . RBRAKET

    RBRAKET         shift and go to state 93


state 62

    (78) rows -> row .
    (79) rows -> row . COMMA rows

    RBRAKET         reduce using rule 78 (rows -> row .)
    COMMA           shift and go to state 94


state 63

    (80) row -> array .

    COMMA           reduce using rule 80 (row -> array .)
    RBRAKET         reduce using rule 80 (row -> array .)


state 64

    (41) control -> UNLESS comptn COLON . cmmd END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 95
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 65

    (43) control -> UNLESS comptn cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 81
    ELSIF           shift and go to state 82

    elses                          shift and go to state 96
    else                           shift and go to state 79
    elsif                          shift and go to state 80

state 66

    (42) control -> UNLESS bool COLON . cmmd END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 97
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 67

    (44) control -> UNLESS bool cmmd . elses END
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 81
    ELSIF           shift and go to state 82

    elses                          shift and go to state 98
    else                           shift and go to state 79
    elsif                          shift and go to state 80

state 68

    (50) control -> CASE ID whens . else END
    (51) control -> CASE ID whens . END
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd

    END             shift and go to state 100
    ELSE            shift and go to state 81

    else                           shift and go to state 99

state 69

    (48) whens -> when .
    (49) whens -> when . whens
    (48) whens -> . when
    (49) whens -> . when whens
    (45) when -> . WHEN objs
    (46) when -> . WHEN objs THEN
    (47) when -> . WHEN comptn

    END             reduce using rule 48 (whens -> when .)
    ELSE            reduce using rule 48 (whens -> when .)
    WHEN            shift and go to state 70

    when                           shift and go to state 69
    whens                          shift and go to state 101

state 70

    (45) when -> WHEN . objs
    (46) when -> WHEN . objs THEN
    (47) when -> WHEN . comptn
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (15) comptn -> . obj comptr obj
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    objs                           shift and go to state 102
    comptn                         shift and go to state 103
    obj                            shift and go to state 104
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 71

    (14) optn -> num optr num .

    $end            reduce using rule 14 (optn -> num optr num .)
    END             reduce using rule 14 (optn -> num optr num .)
    RETURN          reduce using rule 14 (optn -> num optr num .)
    ELSE            reduce using rule 14 (optn -> num optr num .)
    ELSIF           reduce using rule 14 (optn -> num optr num .)


state 72

    (25) func -> DEF ID LPAREN objs . RPAREN cmmd END
    (28) func -> DEF ID LPAREN objs . RPAREN cmmd RETURN obj END

    RPAREN          shift and go to state 105


state 73

    (26) func -> DEF ID LPAREN RPAREN . cmmd END
    (29) func -> DEF ID LPAREN RPAREN . cmmd RETURN obj END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 106
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 74

    (62) objs -> obj .
    (63) objs -> obj . COMMA objs

  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 62 (objs -> obj .)
    RBRAKET         reduce using rule 62 (objs -> obj .)
    THEN            reduce using rule 62 (objs -> obj .)
    WHEN            reduce using rule 62 (objs -> obj .)
    END             reduce using rule 62 (objs -> obj .)
    ELSE            reduce using rule 62 (objs -> obj .)
    COMMA           shift and go to state 107

  ! COMMA           [ reduce using rule 62 (objs -> obj .) ]


state 75

    (27) func -> DEF ID cmmd END .

    $end            reduce using rule 27 (func -> DEF ID cmmd END .)
    END             reduce using rule 27 (func -> DEF ID cmmd END .)
    RETURN          reduce using rule 27 (func -> DEF ID cmmd END .)
    ELSE            reduce using rule 27 (func -> DEF ID cmmd END .)
    ELSIF           reduce using rule 27 (func -> DEF ID cmmd END .)


state 76

    (30) func -> DEF ID cmmd RETURN . obj END
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    obj                            shift and go to state 108
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 77

    (37) control -> IF comptn cmmd END .

    $end            reduce using rule 37 (control -> IF comptn cmmd END .)
    END             reduce using rule 37 (control -> IF comptn cmmd END .)
    RETURN          reduce using rule 37 (control -> IF comptn cmmd END .)
    ELSE            reduce using rule 37 (control -> IF comptn cmmd END .)
    ELSIF           reduce using rule 37 (control -> IF comptn cmmd END .)


state 78

    (39) control -> IF comptn cmmd elses . END

    END             shift and go to state 109


state 79

    (35) elses -> else .

    END             reduce using rule 35 (elses -> else .)


state 80

    (36) elses -> elsif . elses
    (35) elses -> . else
    (36) elses -> . elsif elses
    (31) else -> . ELSE comptn cmmd
    (32) else -> . ELSE bool cmmd
    (33) elsif -> . ELSIF comptn cmmd
    (34) elsif -> . ELSIF bool cmmd

    ELSE            shift and go to state 81
    ELSIF           shift and go to state 82

    elsif                          shift and go to state 80
    elses                          shift and go to state 110
    else                           shift and go to state 79

state 81

    (31) else -> ELSE . comptn cmmd
    (32) else -> ELSE . bool cmmd
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    comptn                         shift and go to state 111
    bool                           shift and go to state 112
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 82

    (33) elsif -> ELSIF . comptn cmmd
    (34) elsif -> ELSIF . bool cmmd
    (15) comptn -> . obj comptr obj
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    comptn                         shift and go to state 113
    bool                           shift and go to state 114
    obj                            shift and go to state 21
    num                            shift and go to state 25
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 83

    (38) control -> IF bool cmmd END .

    $end            reduce using rule 38 (control -> IF bool cmmd END .)
    END             reduce using rule 38 (control -> IF bool cmmd END .)
    RETURN          reduce using rule 38 (control -> IF bool cmmd END .)
    ELSE            reduce using rule 38 (control -> IF bool cmmd END .)
    ELSIF           reduce using rule 38 (control -> IF bool cmmd END .)


state 84

    (40) control -> IF bool cmmd elses . END

    END             shift and go to state 115


state 85

    (15) comptn -> obj comptr obj .

    ID              reduce using rule 15 (comptn -> obj comptr obj .)
    DEF             reduce using rule 15 (comptn -> obj comptr obj .)
    IF              reduce using rule 15 (comptn -> obj comptr obj .)
    UNLESS          reduce using rule 15 (comptn -> obj comptr obj .)
    CASE            reduce using rule 15 (comptn -> obj comptr obj .)
    INT             reduce using rule 15 (comptn -> obj comptr obj .)
    FLOAT           reduce using rule 15 (comptn -> obj comptr obj .)
    RAT             reduce using rule 15 (comptn -> obj comptr obj .)
    COMPX           reduce using rule 15 (comptn -> obj comptr obj .)
    COLON           reduce using rule 15 (comptn -> obj comptr obj .)
    WHEN            reduce using rule 15 (comptn -> obj comptr obj .)
    END             reduce using rule 15 (comptn -> obj comptr obj .)
    ELSE            reduce using rule 15 (comptn -> obj comptr obj .)


state 86

    (72) range -> STRING DOT DOT . STRING

    STRING          shift and go to state 116


state 87

    (70) range -> INT DOT DOT . INT

    INT             shift and go to state 117


state 88

    (69) range -> LPAREN INT DOT . DOT INT RPAREN

    DOT             shift and go to state 118


state 89

    (71) range -> LPAREN STRING DOT . DOT STRING

    DOT             shift and go to state 119


state 90

    (54) array -> LBRAKET objs . RBRAKET
    (56) array -> LBRAKET objs . COMMA ids RBRAKET

    RBRAKET         shift and go to state 120
    COMMA           shift and go to state 121


state 91

    (55) array -> LBRAKET ids . RBRAKET
    (57) array -> LBRAKET ids . COMMA objs RBRAKET

    RBRAKET         shift and go to state 122
    COMMA           shift and go to state 123


state 92

    (52) ids -> ID .
    (53) ids -> ID . COMMA ids

  ! shift/reduce conflict for COMMA resolved as shift
    RBRAKET         reduce using rule 52 (ids -> ID .)
    COMMA           shift and go to state 124

  ! COMMA           [ reduce using rule 52 (ids -> ID .) ]


state 93

    (77) matrix -> LBRAKET rows RBRAKET .

    EQCOMP          reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    LESSTH          reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    LESSEQTH        reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    GREATH          reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    GREATEQTH       reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    NOTEQ           reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    $end            reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    END             reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    RETURN          reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    ELSE            reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    ELSIF           reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    COMMA           reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    RPAREN          reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    ID              reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    DEF             reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    IF              reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    UNLESS          reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    CASE            reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    INT             reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    FLOAT           reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    RAT             reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    COMPX           reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    COLON           reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    WHEN            reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    RBRAKET         reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)
    THEN            reduce using rule 77 (matrix -> LBRAKET rows RBRAKET .)


state 94

    (79) rows -> row COMMA . rows
    (78) rows -> . row
    (79) rows -> . row COMMA rows
    (80) row -> . array
    (54) array -> . LBRAKET objs RBRAKET
    (55) array -> . LBRAKET ids RBRAKET
    (56) array -> . LBRAKET objs COMMA ids RBRAKET
    (57) array -> . LBRAKET ids COMMA objs RBRAKET

    LBRAKET         shift and go to state 60

    row                            shift and go to state 62
    rows                           shift and go to state 125
    array                          shift and go to state 63

state 95

    (41) control -> UNLESS comptn COLON cmmd . END

    END             shift and go to state 126


state 96

    (43) control -> UNLESS comptn cmmd elses . END

    END             shift and go to state 127


state 97

    (42) control -> UNLESS bool COLON cmmd . END

    END             shift and go to state 128


state 98

    (44) control -> UNLESS bool cmmd elses . END

    END             shift and go to state 129


state 99

    (50) control -> CASE ID whens else . END

    END             shift and go to state 130


state 100

    (51) control -> CASE ID whens END .

    $end            reduce using rule 51 (control -> CASE ID whens END .)
    END             reduce using rule 51 (control -> CASE ID whens END .)
    RETURN          reduce using rule 51 (control -> CASE ID whens END .)
    ELSE            reduce using rule 51 (control -> CASE ID whens END .)
    ELSIF           reduce using rule 51 (control -> CASE ID whens END .)


state 101

    (49) whens -> when whens .

    END             reduce using rule 49 (whens -> when whens .)
    ELSE            reduce using rule 49 (whens -> when whens .)


state 102

    (45) when -> WHEN objs .
    (46) when -> WHEN objs . THEN

    WHEN            reduce using rule 45 (when -> WHEN objs .)
    END             reduce using rule 45 (when -> WHEN objs .)
    ELSE            reduce using rule 45 (when -> WHEN objs .)
    THEN            shift and go to state 131


state 103

    (47) when -> WHEN comptn .

    WHEN            reduce using rule 47 (when -> WHEN comptn .)
    END             reduce using rule 47 (when -> WHEN comptn .)
    ELSE            reduce using rule 47 (when -> WHEN comptn .)


state 104

    (62) objs -> obj .
    (63) objs -> obj . COMMA objs
    (15) comptn -> obj . comptr obj
    (16) comptr -> . EQCOMP
    (17) comptr -> . LESSTH
    (18) comptr -> . LESSEQTH
    (19) comptr -> . GREATH
    (20) comptr -> . GREATEQTH
    (21) comptr -> . NOTEQ

    THEN            reduce using rule 62 (objs -> obj .)
    WHEN            reduce using rule 62 (objs -> obj .)
    END             reduce using rule 62 (objs -> obj .)
    ELSE            reduce using rule 62 (objs -> obj .)
    COMMA           shift and go to state 107
    EQCOMP          shift and go to state 50
    LESSTH          shift and go to state 51
    LESSEQTH        shift and go to state 52
    GREATH          shift and go to state 53
    GREATEQTH       shift and go to state 54
    NOTEQ           shift and go to state 55

    comptr                         shift and go to state 49

state 105

    (25) func -> DEF ID LPAREN objs RPAREN . cmmd END
    (28) func -> DEF ID LPAREN objs RPAREN . cmmd RETURN obj END
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 132
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 106

    (26) func -> DEF ID LPAREN RPAREN cmmd . END
    (29) func -> DEF ID LPAREN RPAREN cmmd . RETURN obj END

    END             shift and go to state 133
    RETURN          shift and go to state 134


state 107

    (63) objs -> obj COMMA . objs
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    obj                            shift and go to state 74
    objs                           shift and go to state 135
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 108

    (30) func -> DEF ID cmmd RETURN obj . END

    END             shift and go to state 136


state 109

    (39) control -> IF comptn cmmd elses END .

    $end            reduce using rule 39 (control -> IF comptn cmmd elses END .)
    END             reduce using rule 39 (control -> IF comptn cmmd elses END .)
    RETURN          reduce using rule 39 (control -> IF comptn cmmd elses END .)
    ELSE            reduce using rule 39 (control -> IF comptn cmmd elses END .)
    ELSIF           reduce using rule 39 (control -> IF comptn cmmd elses END .)


state 110

    (36) elses -> elsif elses .

    END             reduce using rule 36 (elses -> elsif elses .)


state 111

    (31) else -> ELSE comptn . cmmd
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 137
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 112

    (32) else -> ELSE bool . cmmd
    (66) obj -> bool .
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 138
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 113

    (33) elsif -> ELSIF comptn . cmmd
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 139
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 114

    (34) elsif -> ELSIF bool . cmmd
    (66) obj -> bool .
    (73) cmmd -> . var
    (74) cmmd -> . func
    (75) cmmd -> . control
    (76) cmmd -> . optn
    (22) var -> . ID EQUALS obj
    (23) var -> . ID EQUALS ID
    (24) var -> . ID EQUALS NIL
    (25) func -> . DEF ID LPAREN objs RPAREN cmmd END
    (26) func -> . DEF ID LPAREN RPAREN cmmd END
    (27) func -> . DEF ID cmmd END
    (28) func -> . DEF ID LPAREN objs RPAREN cmmd RETURN obj END
    (29) func -> . DEF ID LPAREN RPAREN cmmd RETURN obj END
    (30) func -> . DEF ID cmmd RETURN obj END
    (37) control -> . IF comptn cmmd END
    (38) control -> . IF bool cmmd END
    (39) control -> . IF comptn cmmd elses END
    (40) control -> . IF bool cmmd elses END
    (41) control -> . UNLESS comptn COLON cmmd END
    (42) control -> . UNLESS bool COLON cmmd END
    (43) control -> . UNLESS comptn cmmd elses END
    (44) control -> . UNLESS bool cmmd elses END
    (50) control -> . CASE ID whens else END
    (51) control -> . CASE ID whens END
    (14) optn -> . num optr num
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX

    EQCOMP          reduce using rule 66 (obj -> bool .)
    LESSTH          reduce using rule 66 (obj -> bool .)
    LESSEQTH        reduce using rule 66 (obj -> bool .)
    GREATH          reduce using rule 66 (obj -> bool .)
    GREATEQTH       reduce using rule 66 (obj -> bool .)
    NOTEQ           reduce using rule 66 (obj -> bool .)
    ID              shift and go to state 7
    DEF             shift and go to state 8
    IF              shift and go to state 9
    UNLESS          shift and go to state 10
    CASE            shift and go to state 11
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16

    cmmd                           shift and go to state 140
    var                            shift and go to state 3
    func                           shift and go to state 4
    control                        shift and go to state 5
    optn                           shift and go to state 6
    num                            shift and go to state 12

state 115

    (40) control -> IF bool cmmd elses END .

    $end            reduce using rule 40 (control -> IF bool cmmd elses END .)
    END             reduce using rule 40 (control -> IF bool cmmd elses END .)
    RETURN          reduce using rule 40 (control -> IF bool cmmd elses END .)
    ELSE            reduce using rule 40 (control -> IF bool cmmd elses END .)
    ELSIF           reduce using rule 40 (control -> IF bool cmmd elses END .)


state 116

    (72) range -> STRING DOT DOT STRING .

    EQCOMP          reduce using rule 72 (range -> STRING DOT DOT STRING .)
    LESSTH          reduce using rule 72 (range -> STRING DOT DOT STRING .)
    LESSEQTH        reduce using rule 72 (range -> STRING DOT DOT STRING .)
    GREATH          reduce using rule 72 (range -> STRING DOT DOT STRING .)
    GREATEQTH       reduce using rule 72 (range -> STRING DOT DOT STRING .)
    NOTEQ           reduce using rule 72 (range -> STRING DOT DOT STRING .)
    $end            reduce using rule 72 (range -> STRING DOT DOT STRING .)
    END             reduce using rule 72 (range -> STRING DOT DOT STRING .)
    RETURN          reduce using rule 72 (range -> STRING DOT DOT STRING .)
    ELSE            reduce using rule 72 (range -> STRING DOT DOT STRING .)
    ELSIF           reduce using rule 72 (range -> STRING DOT DOT STRING .)
    COMMA           reduce using rule 72 (range -> STRING DOT DOT STRING .)
    RPAREN          reduce using rule 72 (range -> STRING DOT DOT STRING .)
    ID              reduce using rule 72 (range -> STRING DOT DOT STRING .)
    DEF             reduce using rule 72 (range -> STRING DOT DOT STRING .)
    IF              reduce using rule 72 (range -> STRING DOT DOT STRING .)
    UNLESS          reduce using rule 72 (range -> STRING DOT DOT STRING .)
    CASE            reduce using rule 72 (range -> STRING DOT DOT STRING .)
    INT             reduce using rule 72 (range -> STRING DOT DOT STRING .)
    FLOAT           reduce using rule 72 (range -> STRING DOT DOT STRING .)
    RAT             reduce using rule 72 (range -> STRING DOT DOT STRING .)
    COMPX           reduce using rule 72 (range -> STRING DOT DOT STRING .)
    COLON           reduce using rule 72 (range -> STRING DOT DOT STRING .)
    WHEN            reduce using rule 72 (range -> STRING DOT DOT STRING .)
    RBRAKET         reduce using rule 72 (range -> STRING DOT DOT STRING .)
    THEN            reduce using rule 72 (range -> STRING DOT DOT STRING .)


state 117

    (70) range -> INT DOT DOT INT .

    EQCOMP          reduce using rule 70 (range -> INT DOT DOT INT .)
    LESSTH          reduce using rule 70 (range -> INT DOT DOT INT .)
    LESSEQTH        reduce using rule 70 (range -> INT DOT DOT INT .)
    GREATH          reduce using rule 70 (range -> INT DOT DOT INT .)
    GREATEQTH       reduce using rule 70 (range -> INT DOT DOT INT .)
    NOTEQ           reduce using rule 70 (range -> INT DOT DOT INT .)
    $end            reduce using rule 70 (range -> INT DOT DOT INT .)
    END             reduce using rule 70 (range -> INT DOT DOT INT .)
    RETURN          reduce using rule 70 (range -> INT DOT DOT INT .)
    ELSE            reduce using rule 70 (range -> INT DOT DOT INT .)
    ELSIF           reduce using rule 70 (range -> INT DOT DOT INT .)
    COMMA           reduce using rule 70 (range -> INT DOT DOT INT .)
    RPAREN          reduce using rule 70 (range -> INT DOT DOT INT .)
    ID              reduce using rule 70 (range -> INT DOT DOT INT .)
    DEF             reduce using rule 70 (range -> INT DOT DOT INT .)
    IF              reduce using rule 70 (range -> INT DOT DOT INT .)
    UNLESS          reduce using rule 70 (range -> INT DOT DOT INT .)
    CASE            reduce using rule 70 (range -> INT DOT DOT INT .)
    INT             reduce using rule 70 (range -> INT DOT DOT INT .)
    FLOAT           reduce using rule 70 (range -> INT DOT DOT INT .)
    RAT             reduce using rule 70 (range -> INT DOT DOT INT .)
    COMPX           reduce using rule 70 (range -> INT DOT DOT INT .)
    COLON           reduce using rule 70 (range -> INT DOT DOT INT .)
    WHEN            reduce using rule 70 (range -> INT DOT DOT INT .)
    RBRAKET         reduce using rule 70 (range -> INT DOT DOT INT .)
    THEN            reduce using rule 70 (range -> INT DOT DOT INT .)


state 118

    (69) range -> LPAREN INT DOT DOT . INT RPAREN

    INT             shift and go to state 141


state 119

    (71) range -> LPAREN STRING DOT DOT . STRING

    STRING          shift and go to state 142


state 120

    (54) array -> LBRAKET objs RBRAKET .

    COMMA           reduce using rule 54 (array -> LBRAKET objs RBRAKET .)
    RBRAKET         reduce using rule 54 (array -> LBRAKET objs RBRAKET .)


state 121

    (56) array -> LBRAKET objs COMMA . ids RBRAKET
    (52) ids -> . ID
    (53) ids -> . ID COMMA ids

    ID              shift and go to state 92

    ids                            shift and go to state 143

state 122

    (55) array -> LBRAKET ids RBRAKET .

    COMMA           reduce using rule 55 (array -> LBRAKET ids RBRAKET .)
    RBRAKET         reduce using rule 55 (array -> LBRAKET ids RBRAKET .)


state 123

    (57) array -> LBRAKET ids COMMA . objs RBRAKET
    (62) objs -> . obj
    (63) objs -> . obj COMMA objs
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    objs                           shift and go to state 144
    obj                            shift and go to state 74
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 124

    (53) ids -> ID COMMA . ids
    (52) ids -> . ID
    (53) ids -> . ID COMMA ids

    ID              shift and go to state 92

    ids                            shift and go to state 145

state 125

    (79) rows -> row COMMA rows .

    RBRAKET         reduce using rule 79 (rows -> row COMMA rows .)


state 126

    (41) control -> UNLESS comptn COLON cmmd END .

    $end            reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    END             reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    RETURN          reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    ELSE            reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)
    ELSIF           reduce using rule 41 (control -> UNLESS comptn COLON cmmd END .)


state 127

    (43) control -> UNLESS comptn cmmd elses END .

    $end            reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    END             reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    RETURN          reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    ELSE            reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)
    ELSIF           reduce using rule 43 (control -> UNLESS comptn cmmd elses END .)


state 128

    (42) control -> UNLESS bool COLON cmmd END .

    $end            reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    END             reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    RETURN          reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    ELSE            reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)
    ELSIF           reduce using rule 42 (control -> UNLESS bool COLON cmmd END .)


state 129

    (44) control -> UNLESS bool cmmd elses END .

    $end            reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    END             reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    RETURN          reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    ELSE            reduce using rule 44 (control -> UNLESS bool cmmd elses END .)
    ELSIF           reduce using rule 44 (control -> UNLESS bool cmmd elses END .)


state 130

    (50) control -> CASE ID whens else END .

    $end            reduce using rule 50 (control -> CASE ID whens else END .)
    END             reduce using rule 50 (control -> CASE ID whens else END .)
    RETURN          reduce using rule 50 (control -> CASE ID whens else END .)
    ELSE            reduce using rule 50 (control -> CASE ID whens else END .)
    ELSIF           reduce using rule 50 (control -> CASE ID whens else END .)


state 131

    (46) when -> WHEN objs THEN .

    WHEN            reduce using rule 46 (when -> WHEN objs THEN .)
    END             reduce using rule 46 (when -> WHEN objs THEN .)
    ELSE            reduce using rule 46 (when -> WHEN objs THEN .)


state 132

    (25) func -> DEF ID LPAREN objs RPAREN cmmd . END
    (28) func -> DEF ID LPAREN objs RPAREN cmmd . RETURN obj END

    END             shift and go to state 146
    RETURN          shift and go to state 147


state 133

    (26) func -> DEF ID LPAREN RPAREN cmmd END .

    $end            reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    END             reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    RETURN          reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    ELSE            reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)
    ELSIF           reduce using rule 26 (func -> DEF ID LPAREN RPAREN cmmd END .)


state 134

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN . obj END
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    obj                            shift and go to state 148
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 135

    (63) objs -> obj COMMA objs .

    RPAREN          reduce using rule 63 (objs -> obj COMMA objs .)
    RBRAKET         reduce using rule 63 (objs -> obj COMMA objs .)
    COMMA           reduce using rule 63 (objs -> obj COMMA objs .)
    THEN            reduce using rule 63 (objs -> obj COMMA objs .)
    WHEN            reduce using rule 63 (objs -> obj COMMA objs .)
    END             reduce using rule 63 (objs -> obj COMMA objs .)
    ELSE            reduce using rule 63 (objs -> obj COMMA objs .)


state 136

    (30) func -> DEF ID cmmd RETURN obj END .

    $end            reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    END             reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    RETURN          reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    ELSE            reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)
    ELSIF           reduce using rule 30 (func -> DEF ID cmmd RETURN obj END .)


state 137

    (31) else -> ELSE comptn cmmd .

    END             reduce using rule 31 (else -> ELSE comptn cmmd .)


state 138

    (32) else -> ELSE bool cmmd .

    END             reduce using rule 32 (else -> ELSE bool cmmd .)


state 139

    (33) elsif -> ELSIF comptn cmmd .

    ELSE            reduce using rule 33 (elsif -> ELSIF comptn cmmd .)
    ELSIF           reduce using rule 33 (elsif -> ELSIF comptn cmmd .)


state 140

    (34) elsif -> ELSIF bool cmmd .

    ELSE            reduce using rule 34 (elsif -> ELSIF bool cmmd .)
    ELSIF           reduce using rule 34 (elsif -> ELSIF bool cmmd .)


state 141

    (69) range -> LPAREN INT DOT DOT INT . RPAREN

    RPAREN          shift and go to state 149


state 142

    (71) range -> LPAREN STRING DOT DOT STRING .

    EQCOMP          reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    LESSTH          reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    LESSEQTH        reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    GREATH          reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    GREATEQTH       reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    NOTEQ           reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    $end            reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    END             reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    RETURN          reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    ELSE            reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    ELSIF           reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    COMMA           reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    RPAREN          reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    ID              reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    DEF             reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    IF              reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    UNLESS          reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    CASE            reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    INT             reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    FLOAT           reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    RAT             reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    COMPX           reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    COLON           reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    WHEN            reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    RBRAKET         reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)
    THEN            reduce using rule 71 (range -> LPAREN STRING DOT DOT STRING .)


state 143

    (56) array -> LBRAKET objs COMMA ids . RBRAKET

    RBRAKET         shift and go to state 150


state 144

    (57) array -> LBRAKET ids COMMA objs . RBRAKET

    RBRAKET         shift and go to state 151


state 145

    (53) ids -> ID COMMA ids .

    RBRAKET         reduce using rule 53 (ids -> ID COMMA ids .)
    COMMA           reduce using rule 53 (ids -> ID COMMA ids .)


state 146

    (25) func -> DEF ID LPAREN objs RPAREN cmmd END .

    $end            reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    END             reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    RETURN          reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    ELSE            reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)
    ELSIF           reduce using rule 25 (func -> DEF ID LPAREN objs RPAREN cmmd END .)


state 147

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN . obj END
    (64) obj -> . STRING
    (65) obj -> . num
    (66) obj -> . bool
    (67) obj -> . range
    (68) obj -> . matrix
    (4) num -> . INT
    (5) num -> . FLOAT
    (6) num -> . RAT
    (7) num -> . COMPX
    (2) bool -> . TRUE
    (3) bool -> . FALSE
    (69) range -> . LPAREN INT DOT DOT INT RPAREN
    (70) range -> . INT DOT DOT INT
    (71) range -> . LPAREN STRING DOT DOT STRING
    (72) range -> . STRING DOT DOT STRING
    (77) matrix -> . LBRAKET rows RBRAKET

    STRING          shift and go to state 24
    INT             shift and go to state 28
    FLOAT           shift and go to state 14
    RAT             shift and go to state 15
    COMPX           shift and go to state 16
    TRUE            shift and go to state 22
    FALSE           shift and go to state 23
    LPAREN          shift and go to state 29
    LBRAKET         shift and go to state 30

    obj                            shift and go to state 152
    num                            shift and go to state 25
    bool                           shift and go to state 44
    range                          shift and go to state 26
    matrix                         shift and go to state 27

state 148

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN obj . END

    END             shift and go to state 153


state 149

    (69) range -> LPAREN INT DOT DOT INT RPAREN .

    EQCOMP          reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    LESSTH          reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    LESSEQTH        reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    GREATH          reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    GREATEQTH       reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    NOTEQ           reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    $end            reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    END             reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RETURN          reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ELSE            reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ELSIF           reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COMMA           reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RPAREN          reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    ID              reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    DEF             reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    IF              reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    UNLESS          reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    CASE            reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    INT             reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    FLOAT           reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RAT             reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COMPX           reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    COLON           reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    WHEN            reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    RBRAKET         reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)
    THEN            reduce using rule 69 (range -> LPAREN INT DOT DOT INT RPAREN .)


state 150

    (56) array -> LBRAKET objs COMMA ids RBRAKET .

    COMMA           reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)
    RBRAKET         reduce using rule 56 (array -> LBRAKET objs COMMA ids RBRAKET .)


state 151

    (57) array -> LBRAKET ids COMMA objs RBRAKET .

    COMMA           reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)
    RBRAKET         reduce using rule 57 (array -> LBRAKET ids COMMA objs RBRAKET .)


state 152

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj . END

    END             shift and go to state 154


state 153

    (29) func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .

    $end            reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    END             reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    RETURN          reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    ELSE            reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)
    ELSIF           reduce using rule 29 (func -> DEF ID LPAREN RPAREN cmmd RETURN obj END .)


state 154

    (28) func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .

    $end            reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    END             reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    RETURN          reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    ELSE            reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)
    ELSIF           reduce using rule 28 (func -> DEF ID LPAREN objs RPAREN cmmd RETURN obj END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COMMA in state 74 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 92 resolved as shift
